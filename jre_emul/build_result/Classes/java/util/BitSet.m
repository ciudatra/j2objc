//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/util/BitSet.java
//
//  Created by retechretech on 13-4-19.
//

#import "IOSLongArray.h"
#import "java/lang/IndexOutOfBoundsException.h"
#import "java/lang/Math.h"
#import "java/lang/NegativeArraySizeException.h"
#import "java/lang/StringBuilder.h"
#import "java/lang/System.h"
#import "java/util/BitSet.h"

@implementation JavaUtilBitSet

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaUtilBitSet_TWO_N_ARRAY_ name:@"JavaUtilBitSet_TWO_N_ARRAY_"]];
  return result;
}

static IOSLongArray * JavaUtilBitSet_TWO_N_ARRAY_;

- (IOSLongArray *)bits {
  return bits_;
}
- (void)setBits:(IOSLongArray *)bits {
  JreOperatorRetainedAssign(&bits_, bits);
}
@synthesize bits = bits_;
@synthesize needClear_ = needClear__;
@synthesize actualArrayLength = actualArrayLength_;
@synthesize isLengthActual = isLengthActual_;

+ (IOSLongArray *)TWO_N_ARRAY {
  return JavaUtilBitSet_TWO_N_ARRAY_;
}

- (id)init {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&bits_, [[[IOSLongArray alloc] initWithLength:1] autorelease]);
    actualArrayLength_ = 0;
    isLengthActual_ = YES;
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithInt:(int)nbits {
  if ((self = [super init])) {
    if (nbits < 0) {
      @throw [[[JavaLangNegativeArraySizeException alloc] init] autorelease];
    }
    JreOperatorRetainedAssign(&bits_, [[[IOSLongArray alloc] initWithLength:(nbits >> JavaUtilBitSet_OFFSET) + ((nbits & JavaUtilBitSet_RIGHT_BITS) > 0 ? 1 : 0)] autorelease]);
    actualArrayLength_ = 0;
    isLengthActual_ = YES;
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaLangLongArray:(IOSLongArray *)bits
                       withBOOL:(BOOL)needClear
                        withInt:(int)actualArrayLength
                       withBOOL:(BOOL)isLengthActual {
  if ((self = [super init])) {
    self.bits = bits;
    self.needClear_ = needClear;
    self.actualArrayLength = actualArrayLength;
    self.isLengthActual = isLengthActual;
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)clone {
  JavaUtilBitSet *clone = [[[JavaUtilBitSet alloc] init] autorelease];
  ((JavaUtilBitSet *) NIL_CHK(clone)).actualArrayLength = actualArrayLength_;
  ((JavaUtilBitSet *) NIL_CHK(clone)).bits = [((IOSLongArray *) NIL_CHK(bits_)) clone];
  ((JavaUtilBitSet *) NIL_CHK(clone)).isLengthActual = isLengthActual_;
  ((JavaUtilBitSet *) NIL_CHK(clone)).needClear_ = needClear__;
  return clone;
}

- (BOOL)isEqual:(id)obj {
  if (self == obj) {
    return YES;
  }
  if ([obj isKindOfClass:[JavaUtilBitSet class]]) {
    IOSLongArray *bsBits = ((JavaUtilBitSet *) obj).bits;
    int length1 = self.actualArrayLength, length2 = ((JavaUtilBitSet *) obj).actualArrayLength;
    if (self.isLengthActual && ((JavaUtilBitSet *) obj).isLengthActual && length1 != length2) {
      return NO;
    }
    if (length1 <= length2) {
      for (int i = 0; i < length1; i++) {
        if ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:i] != [((IOSLongArray *) NIL_CHK(bsBits)) longAtIndex:i]) {
          return NO;
        }
      }
      for (int i = length1; i < length2; i++) {
        if ([((IOSLongArray *) NIL_CHK(bsBits)) longAtIndex:i] != 0) {
          return NO;
        }
      }
    }
    else {
      for (int i = 0; i < length2; i++) {
        if ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:i] != [((IOSLongArray *) NIL_CHK(bsBits)) longAtIndex:i]) {
          return NO;
        }
      }
      for (int i = length2; i < length1; i++) {
        if ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:i] != 0) {
          return NO;
        }
      }
    }
    return YES;
  }
  return NO;
}

- (void)growLengthWithInt:(int)len {
  IOSLongArray *tempBits = [[[IOSLongArray alloc] initWithLength:[JavaLangMath maxWithInt:len withInt:(int) [((IOSLongArray *) NIL_CHK(bits_)) count] * 2]] autorelease];
  [JavaLangSystem arraycopyWithId:bits_ withInt:0 withId:tempBits withInt:0 withInt:self.actualArrayLength];
  JreOperatorRetainedAssign(&bits_, tempBits);
}

- (NSUInteger)hash {
  long long int x = 1234;
  for (int i = 0, length = actualArrayLength_; i < length; i++) {
    x ^= [((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:i] * (i + 1);
  }
  return (int) ((x >> 32) ^ x);
}

- (BOOL)getWithInt:(int)pos {
  if (pos < 0) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"Negative index specified"] autorelease];
  }
  int arrayPos = pos >> JavaUtilBitSet_OFFSET;
  if (arrayPos < actualArrayLength_) {
    return ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:arrayPos] & [((IOSLongArray *) NIL_CHK(JavaUtilBitSet_TWO_N_ARRAY_)) longAtIndex:pos & JavaUtilBitSet_RIGHT_BITS]) != 0;
  }
  return NO;
}

- (JavaUtilBitSet *)getWithInt:(int)pos1
                       withInt:(int)pos2 {
  if (pos1 < 0 || pos2 < 0 || pos2 < pos1) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"Negative index specified"] autorelease];
  }
  int last = actualArrayLength_ << JavaUtilBitSet_OFFSET;
  if (pos1 >= last || pos1 == pos2) {
    return [[[JavaUtilBitSet alloc] initWithInt:0] autorelease];
  }
  if (pos2 > last) {
    pos2 = last;
  }
  int idx1 = pos1 >> JavaUtilBitSet_OFFSET;
  int idx2 = (pos2 - 1) >> JavaUtilBitSet_OFFSET;
  long long int factor1 = (~0LL) << (pos1 & JavaUtilBitSet_RIGHT_BITS);
  long long int factor2 = (long long) (((unsigned long long) (~0LL)) >> (JavaUtilBitSet_ELM_SIZE - (pos2 & JavaUtilBitSet_RIGHT_BITS)));
  if (idx1 == idx2) {
    long long int result = (long long) (((unsigned long long) ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx1] & (factor1 & factor2))) >> (pos1 % JavaUtilBitSet_ELM_SIZE));
    if (result == 0) {
      return [[[JavaUtilBitSet alloc] initWithInt:0] autorelease];
    }
    return [[[JavaUtilBitSet alloc] initWithJavaLangLongArray:[IOSLongArray arrayWithLongs:(long long int[]){ result } count:1] withBOOL:needClear__ withInt:1 withBOOL:YES] autorelease];
  }
  IOSLongArray *newbits = [[[IOSLongArray alloc] initWithLength:idx2 - idx1 + 1] autorelease];
  [((IOSLongArray *) NIL_CHK(newbits)) replaceLongAtIndex:0 withLong:[((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx1] & factor1];
  [((IOSLongArray *) NIL_CHK(newbits)) replaceLongAtIndex:(int) [((IOSLongArray *) NIL_CHK(newbits)) count] - 1 withLong:[((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx2] & factor2];
  for (int i = 1; i < idx2 - idx1; i++) {
    [((IOSLongArray *) NIL_CHK(newbits)) replaceLongAtIndex:i withLong:[((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx1 + i]];
  }
  int numBitsToShift = pos1 & JavaUtilBitSet_RIGHT_BITS;
  int actualLen = (int) [((IOSLongArray *) NIL_CHK(newbits)) count];
  if (numBitsToShift != 0) {
    for (int i = 0; i < (int) [((IOSLongArray *) NIL_CHK(newbits)) count]; i++) {
      [((IOSLongArray *) NIL_CHK(newbits)) replaceLongAtIndex:i withLong:(long long) (((unsigned long long) [((IOSLongArray *) NIL_CHK(newbits)) longAtIndex:i]) >> (numBitsToShift))];
      if (i != (int) [((IOSLongArray *) NIL_CHK(newbits)) count] - 1) {
        [((IOSLongArray *) NIL_CHK(newbits)) replaceLongAtIndex:i withLong:[newbits longAtIndex:i] | [((IOSLongArray *) NIL_CHK(newbits)) longAtIndex:i + 1] << (JavaUtilBitSet_ELM_SIZE - (numBitsToShift))];
      }
      if ([((IOSLongArray *) NIL_CHK(newbits)) longAtIndex:i] != 0) {
        actualLen = i + 1;
      }
    }
  }
  return [[[JavaUtilBitSet alloc] initWithJavaLangLongArray:newbits withBOOL:needClear__ withInt:actualLen withBOOL:[((IOSLongArray *) NIL_CHK(newbits)) longAtIndex:actualLen - 1] != 0] autorelease];
}

- (void)setWithInt:(int)pos {
  if (pos < 0) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"Negative index specified"] autorelease];
  }
  int len = (pos >> JavaUtilBitSet_OFFSET) + 1;
  if (len > (int) [((IOSLongArray *) NIL_CHK(bits_)) count]) {
    [self growLengthWithInt:len];
  }
  [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:len - 1 withLong:[bits_ longAtIndex:len - 1] | [((IOSLongArray *) NIL_CHK(JavaUtilBitSet_TWO_N_ARRAY_)) longAtIndex:pos & JavaUtilBitSet_RIGHT_BITS]];
  if (len > actualArrayLength_) {
    actualArrayLength_ = len;
    isLengthActual_ = YES;
  }
  [self needClear];
}

- (void)setWithInt:(int)pos
          withBOOL:(BOOL)val {
  if (val) {
    [self setWithInt:pos];
  }
  else {
    [self clearWithInt:pos];
  }
}

- (void)setWithInt:(int)pos1
           withInt:(int)pos2 {
  if (pos1 < 0 || pos2 < 0 || pos2 < pos1) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"Negative index specified"] autorelease];
  }
  if (pos1 == pos2) {
    return;
  }
  int len2 = ((pos2 - 1) >> JavaUtilBitSet_OFFSET) + 1;
  if (len2 > (int) [((IOSLongArray *) NIL_CHK(bits_)) count]) {
    [self growLengthWithInt:len2];
  }
  int idx1 = pos1 >> JavaUtilBitSet_OFFSET;
  int idx2 = (pos2 - 1) >> JavaUtilBitSet_OFFSET;
  long long int factor1 = (~0LL) << (pos1 & JavaUtilBitSet_RIGHT_BITS);
  long long int factor2 = (long long) (((unsigned long long) (~0LL)) >> (JavaUtilBitSet_ELM_SIZE - (pos2 & JavaUtilBitSet_RIGHT_BITS)));
  if (idx1 == idx2) {
    [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:idx1 withLong:[bits_ longAtIndex:idx1] | (factor1 & factor2)];
  }
  else {
    [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:idx1 withLong:[bits_ longAtIndex:idx1] | factor1];
    [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:idx2 withLong:[bits_ longAtIndex:idx2] | factor2];
    for (int i = idx1 + 1; i < idx2; i++) {
      [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:i withLong:[bits_ longAtIndex:i] | (~0LL)];
    }
  }
  if (idx2 + 1 > actualArrayLength_) {
    actualArrayLength_ = idx2 + 1;
    isLengthActual_ = YES;
  }
  [self needClear];
}

- (void)needClear {
  self.needClear_ = YES;
}

- (void)setWithInt:(int)pos1
           withInt:(int)pos2
          withBOOL:(BOOL)val {
  if (val) {
    [self setWithInt:pos1 withInt:pos2];
  }
  else {
    [self clearWithInt:pos1 withInt:pos2];
  }
}

- (void)clear {
  if (needClear__) {
    for (int i = 0; i < (int) [((IOSLongArray *) NIL_CHK(bits_)) count]; i++) {
      [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:i withLong:0LL];
    }
    actualArrayLength_ = 0;
    isLengthActual_ = YES;
    needClear__ = NO;
  }
}

- (void)clearWithInt:(int)pos {
  if (pos < 0) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"Negative index specified"] autorelease];
  }
  if (!needClear__) {
    return;
  }
  int arrayPos = pos >> JavaUtilBitSet_OFFSET;
  if (arrayPos < actualArrayLength_) {
    [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:arrayPos withLong:[bits_ longAtIndex:arrayPos] & ~([((IOSLongArray *) NIL_CHK(JavaUtilBitSet_TWO_N_ARRAY_)) longAtIndex:pos & JavaUtilBitSet_RIGHT_BITS])];
    if ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:actualArrayLength_ - 1] == 0) {
      isLengthActual_ = NO;
    }
  }
}

- (void)clearWithInt:(int)pos1
             withInt:(int)pos2 {
  if (pos1 < 0 || pos2 < 0 || pos2 < pos1) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"Negative index specified"] autorelease];
  }
  if (!needClear__) {
    return;
  }
  int last = (actualArrayLength_ << JavaUtilBitSet_OFFSET);
  if (pos1 >= last || pos1 == pos2) {
    return;
  }
  if (pos2 > last) {
    pos2 = last;
  }
  int idx1 = pos1 >> JavaUtilBitSet_OFFSET;
  int idx2 = (pos2 - 1) >> JavaUtilBitSet_OFFSET;
  long long int factor1 = (~0LL) << (pos1 & JavaUtilBitSet_RIGHT_BITS);
  long long int factor2 = (long long) (((unsigned long long) (~0LL)) >> (JavaUtilBitSet_ELM_SIZE - (pos2 & JavaUtilBitSet_RIGHT_BITS)));
  if (idx1 == idx2) {
    [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:idx1 withLong:[bits_ longAtIndex:idx1] & ~(factor1 & factor2)];
  }
  else {
    [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:idx1 withLong:[bits_ longAtIndex:idx1] & ~factor1];
    [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:idx2 withLong:[bits_ longAtIndex:idx2] & ~factor2];
    for (int i = idx1 + 1; i < idx2; i++) {
      [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:i withLong:0LL];
    }
  }
  if ((actualArrayLength_ > 0) && ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:actualArrayLength_ - 1] == 0)) {
    isLengthActual_ = NO;
  }
}

- (void)flipWithInt:(int)pos {
  if (pos < 0) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"Negative index specified"] autorelease];
  }
  int len = (pos >> JavaUtilBitSet_OFFSET) + 1;
  if (len > (int) [((IOSLongArray *) NIL_CHK(bits_)) count]) {
    [self growLengthWithInt:len];
  }
  [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:len - 1 withLong:[bits_ longAtIndex:len - 1] ^ [((IOSLongArray *) NIL_CHK(JavaUtilBitSet_TWO_N_ARRAY_)) longAtIndex:pos & JavaUtilBitSet_RIGHT_BITS]];
  if (len > actualArrayLength_) {
    actualArrayLength_ = len;
  }
  isLengthActual_ = !((actualArrayLength_ > 0) && ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:actualArrayLength_ - 1] == 0));
  [self needClear];
}

- (void)flipWithInt:(int)pos1
            withInt:(int)pos2 {
  if (pos1 < 0 || pos2 < 0 || pos2 < pos1) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"Negative index specified"] autorelease];
  }
  if (pos1 == pos2) {
    return;
  }
  int len2 = ((pos2 - 1) >> JavaUtilBitSet_OFFSET) + 1;
  if (len2 > (int) [((IOSLongArray *) NIL_CHK(bits_)) count]) {
    [self growLengthWithInt:len2];
  }
  int idx1 = pos1 >> JavaUtilBitSet_OFFSET;
  int idx2 = (pos2 - 1) >> JavaUtilBitSet_OFFSET;
  long long int factor1 = (~0LL) << (pos1 & JavaUtilBitSet_RIGHT_BITS);
  long long int factor2 = (long long) (((unsigned long long) (~0LL)) >> (JavaUtilBitSet_ELM_SIZE - (pos2 & JavaUtilBitSet_RIGHT_BITS)));
  if (idx1 == idx2) {
    [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:idx1 withLong:[bits_ longAtIndex:idx1] ^ (factor1 & factor2)];
  }
  else {
    [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:idx1 withLong:[bits_ longAtIndex:idx1] ^ factor1];
    [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:idx2 withLong:[bits_ longAtIndex:idx2] ^ factor2];
    for (int i = idx1 + 1; i < idx2; i++) {
      [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:i withLong:[bits_ longAtIndex:i] ^ (~0LL)];
    }
  }
  if (len2 > actualArrayLength_) {
    actualArrayLength_ = len2;
  }
  isLengthActual_ = !((actualArrayLength_ > 0) && ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:actualArrayLength_ - 1] == 0));
  [self needClear];
}

- (BOOL)intersectsWithJavaUtilBitSet:(JavaUtilBitSet *)bs {
  IOSLongArray *bsBits = ((JavaUtilBitSet *) NIL_CHK(bs)).bits;
  int length1 = actualArrayLength_, length2 = ((JavaUtilBitSet *) NIL_CHK(bs)).actualArrayLength;
  if (length1 <= length2) {
    for (int i = 0; i < length1; i++) {
      if (([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:i] & [((IOSLongArray *) NIL_CHK(bsBits)) longAtIndex:i]) != 0LL) {
        return YES;
      }
    }
  }
  else {
    for (int i = 0; i < length2; i++) {
      if (([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:i] & [((IOSLongArray *) NIL_CHK(bsBits)) longAtIndex:i]) != 0LL) {
        return YES;
      }
    }
  }
  return NO;
}

- (void)andWithJavaUtilBitSet:(JavaUtilBitSet *)bs {
  IOSLongArray *bsBits = ((JavaUtilBitSet *) NIL_CHK(bs)).bits;
  if (!needClear__) {
    return;
  }
  int length1 = actualArrayLength_, length2 = ((JavaUtilBitSet *) NIL_CHK(bs)).actualArrayLength;
  if (length1 <= length2) {
    for (int i = 0; i < length1; i++) {
      [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:i withLong:[bits_ longAtIndex:i] & [((IOSLongArray *) NIL_CHK(bsBits)) longAtIndex:i]];
    }
  }
  else {
    for (int i = 0; i < length2; i++) {
      [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:i withLong:[bits_ longAtIndex:i] & [((IOSLongArray *) NIL_CHK(bsBits)) longAtIndex:i]];
    }
    for (int i = length2; i < length1; i++) {
      [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:i withLong:0];
    }
    actualArrayLength_ = length2;
  }
  isLengthActual_ = !((actualArrayLength_ > 0) && ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:actualArrayLength_ - 1] == 0));
}

- (void)andNotWithJavaUtilBitSet:(JavaUtilBitSet *)bs {
  IOSLongArray *bsBits = ((JavaUtilBitSet *) NIL_CHK(bs)).bits;
  if (!needClear__) {
    return;
  }
  int range = actualArrayLength_ < ((JavaUtilBitSet *) NIL_CHK(bs)).actualArrayLength ? actualArrayLength_ : ((JavaUtilBitSet *) NIL_CHK(bs)).actualArrayLength;
  for (int i = 0; i < range; i++) {
    [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:i withLong:[bits_ longAtIndex:i] & ~[((IOSLongArray *) NIL_CHK(bsBits)) longAtIndex:i]];
  }
  if (actualArrayLength_ < range) {
    actualArrayLength_ = range;
  }
  isLengthActual_ = !((actualArrayLength_ > 0) && ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:actualArrayLength_ - 1] == 0));
}

- (void)orWithJavaUtilBitSet:(JavaUtilBitSet *)bs {
  int bsActualLen = [((JavaUtilBitSet *) NIL_CHK(bs)) getActualArrayLength];
  if (bsActualLen > (int) [((IOSLongArray *) NIL_CHK(bits_)) count]) {
    IOSLongArray *tempBits = [[[IOSLongArray alloc] initWithLength:bsActualLen] autorelease];
    [JavaLangSystem arraycopyWithId:((JavaUtilBitSet *) NIL_CHK(bs)).bits withInt:0 withId:tempBits withInt:0 withInt:((JavaUtilBitSet *) NIL_CHK(bs)).actualArrayLength];
    for (int i = 0; i < actualArrayLength_; i++) {
      [((IOSLongArray *) NIL_CHK(tempBits)) replaceLongAtIndex:i withLong:[tempBits longAtIndex:i] | [((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:i]];
    }
    JreOperatorRetainedAssign(&bits_, tempBits);
    actualArrayLength_ = bsActualLen;
    isLengthActual_ = YES;
  }
  else {
    IOSLongArray *bsBits = ((JavaUtilBitSet *) NIL_CHK(bs)).bits;
    for (int i = 0; i < bsActualLen; i++) {
      [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:i withLong:[bits_ longAtIndex:i] | [((IOSLongArray *) NIL_CHK(bsBits)) longAtIndex:i]];
    }
    if (bsActualLen > actualArrayLength_) {
      actualArrayLength_ = bsActualLen;
      isLengthActual_ = YES;
    }
  }
  [self needClear];
}

- (void)xorWithJavaUtilBitSet:(JavaUtilBitSet *)bs {
  int bsActualLen = [((JavaUtilBitSet *) NIL_CHK(bs)) getActualArrayLength];
  if (bsActualLen > (int) [((IOSLongArray *) NIL_CHK(bits_)) count]) {
    IOSLongArray *tempBits = [[[IOSLongArray alloc] initWithLength:bsActualLen] autorelease];
    [JavaLangSystem arraycopyWithId:((JavaUtilBitSet *) NIL_CHK(bs)).bits withInt:0 withId:tempBits withInt:0 withInt:((JavaUtilBitSet *) NIL_CHK(bs)).actualArrayLength];
    for (int i = 0; i < actualArrayLength_; i++) {
      [((IOSLongArray *) NIL_CHK(tempBits)) replaceLongAtIndex:i withLong:[tempBits longAtIndex:i] ^ [((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:i]];
    }
    JreOperatorRetainedAssign(&bits_, tempBits);
    actualArrayLength_ = bsActualLen;
    isLengthActual_ = !((actualArrayLength_ > 0) && ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:actualArrayLength_ - 1] == 0));
  }
  else {
    IOSLongArray *bsBits = ((JavaUtilBitSet *) NIL_CHK(bs)).bits;
    for (int i = 0; i < bsActualLen; i++) {
      [((IOSLongArray *) NIL_CHK(bits_)) replaceLongAtIndex:i withLong:[bits_ longAtIndex:i] ^ [((IOSLongArray *) NIL_CHK(bsBits)) longAtIndex:i]];
    }
    if (bsActualLen > actualArrayLength_) {
      actualArrayLength_ = bsActualLen;
      isLengthActual_ = YES;
    }
  }
  [self needClear];
}

- (int)size {
  return (int) [((IOSLongArray *) NIL_CHK(bits_)) count] << JavaUtilBitSet_OFFSET;
}

- (int)length {
  int idx = actualArrayLength_ - 1;
  while (idx >= 0 && [((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] == 0) {
    --idx;
  }
  actualArrayLength_ = idx + 1;
  if (idx == -1) {
    return 0;
  }
  int i = JavaUtilBitSet_ELM_SIZE - 1;
  long long int val = [((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx];
  while ((val & ([((IOSLongArray *) NIL_CHK(JavaUtilBitSet_TWO_N_ARRAY_)) longAtIndex:i])) == 0 && i > 0) {
    i--;
  }
  return (idx << JavaUtilBitSet_OFFSET) + i + 1;
}

- (int)getActualArrayLength {
  if (isLengthActual_) {
    return actualArrayLength_;
  }
  int idx = actualArrayLength_ - 1;
  while (idx >= 0 && [((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] == 0) {
    --idx;
  }
  actualArrayLength_ = idx + 1;
  isLengthActual_ = YES;
  return actualArrayLength_;
}

- (NSString *)description {
  JavaLangStringBuilder *sb = [[[JavaLangStringBuilder alloc] initWithInt:(int) [((IOSLongArray *) NIL_CHK(bits_)) count] / 2] autorelease];
  int bitCount = 0;
  [((JavaLangStringBuilder *) NIL_CHK(sb)) appendWithUnichar:'{'];
  BOOL comma = NO;
  for (int i = 0; i < (int) [((IOSLongArray *) NIL_CHK(bits_)) count]; i++) {
    if ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:i] == 0) {
      bitCount += JavaUtilBitSet_ELM_SIZE;
      continue;
    }
    for (int j = 0; j < JavaUtilBitSet_ELM_SIZE; j++) {
      if ((([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:i] & ([((IOSLongArray *) NIL_CHK(JavaUtilBitSet_TWO_N_ARRAY_)) longAtIndex:j])) != 0)) {
        if (comma) {
          [((JavaLangStringBuilder *) NIL_CHK(sb)) appendWithNSString:@", "];
        }
        [((JavaLangStringBuilder *) NIL_CHK(sb)) appendWithInt:bitCount];
        comma = YES;
      }
      bitCount++;
    }
  }
  [((JavaLangStringBuilder *) NIL_CHK(sb)) appendWithUnichar:'}'];
  return [((JavaLangStringBuilder *) NIL_CHK(sb)) description];
}

- (int)nextSetBitWithInt:(int)pos {
  if (pos < 0) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"Negative index specified"] autorelease];
  }
  if (pos >= actualArrayLength_ << JavaUtilBitSet_OFFSET) {
    return -1;
  }
  int idx = pos >> JavaUtilBitSet_OFFSET;
  if ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] != 0LL) {
    for (int j = pos & JavaUtilBitSet_RIGHT_BITS; j < JavaUtilBitSet_ELM_SIZE; j++) {
      if ((([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] & ([((IOSLongArray *) NIL_CHK(JavaUtilBitSet_TWO_N_ARRAY_)) longAtIndex:j])) != 0)) {
        return (idx << JavaUtilBitSet_OFFSET) + j;
      }
    }
  }
  idx++;
  while (idx < actualArrayLength_ && [((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] == 0LL) {
    idx++;
  }
  if (idx == actualArrayLength_) {
    return -1;
  }
  for (int j = 0; j < JavaUtilBitSet_ELM_SIZE; j++) {
    if ((([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] & ([((IOSLongArray *) NIL_CHK(JavaUtilBitSet_TWO_N_ARRAY_)) longAtIndex:j])) != 0)) {
      return (idx << JavaUtilBitSet_OFFSET) + j;
    }
  }
  return -1;
}

- (int)nextClearBitWithInt:(int)pos {
  if (pos < 0) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"Negative index specified"] autorelease];
  }
  int length = actualArrayLength_;
  int bssize = length << JavaUtilBitSet_OFFSET;
  if (pos >= bssize) {
    return pos;
  }
  int idx = pos >> JavaUtilBitSet_OFFSET;
  if ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] != (~0LL)) {
    for (int j = pos % JavaUtilBitSet_ELM_SIZE; j < JavaUtilBitSet_ELM_SIZE; j++) {
      if ((([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] & ([((IOSLongArray *) NIL_CHK(JavaUtilBitSet_TWO_N_ARRAY_)) longAtIndex:j])) == 0)) {
        return idx * JavaUtilBitSet_ELM_SIZE + j;
      }
    }
  }
  idx++;
  while (idx < length && [((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] == (~0LL)) {
    idx++;
  }
  if (idx == length) {
    return bssize;
  }
  for (int j = 0; j < JavaUtilBitSet_ELM_SIZE; j++) {
    if ((([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] & ([((IOSLongArray *) NIL_CHK(JavaUtilBitSet_TWO_N_ARRAY_)) longAtIndex:j])) == 0)) {
      return (idx << JavaUtilBitSet_OFFSET) + j;
    }
  }
  return bssize;
}

- (BOOL)isEmpty {
  if (!needClear__) {
    return YES;
  }
  int length = (int) [((IOSLongArray *) NIL_CHK(bits_)) count];
  for (int idx = 0; idx < length; idx++) {
    if ([((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] != 0LL) {
      return NO;
    }
  }
  return YES;
}

- (int)cardinality {
  if (!needClear__) {
    return 0;
  }
  int count = 0;
  int length = (int) [((IOSLongArray *) NIL_CHK(bits_)) count];
  for (int idx = 0; idx < length; idx++) {
    count += [self popWithLongInt:[((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx] & (long long) 0xffffffffLL];
    count += [self popWithLongInt:(long long) (((unsigned long long) [((IOSLongArray *) NIL_CHK(bits_)) longAtIndex:idx]) >> 32)];
  }
  return count;
}

- (int)popWithLongInt:(long long int)x {
  x = x - (((long long) (((unsigned long long) x) >> 1)) & (int) 0x55555555);
  x = (x & (int) 0x33333333) + (((long long) (((unsigned long long) x) >> 2)) & (int) 0x33333333);
  x = (x + ((long long) (((unsigned long long) x) >> 4))) & (int) 0x0f0f0f0f;
  x = x + ((long long) (((unsigned long long) x) >> 8));
  x = x + ((long long) (((unsigned long long) x) >> 16));
  return (int) x & (int) 0x0000003f;
}

+ (void)initialize {
  if (self == [JavaUtilBitSet class]) {
    JreOperatorRetainedAssign(&JavaUtilBitSet_TWO_N_ARRAY_, [IOSLongArray arrayWithLongs:(long long int[]){ (long long) 0x1LL, (long long) 0x2LL, (long long) 0x4LL, (long long) 0x8LL, (long long) 0x10LL, (long long) 0x20LL, (long long) 0x40LL, (long long) 0x80LL, (long long) 0x100LL, (long long) 0x200LL, (long long) 0x400LL, (long long) 0x800LL, (long long) 0x1000LL, (long long) 0x2000LL, (long long) 0x4000LL, (long long) 0x8000LL, (long long) 0x10000LL, (long long) 0x20000LL, (long long) 0x40000LL, (long long) 0x80000LL, (long long) 0x100000LL, (long long) 0x200000LL, (long long) 0x400000LL, (long long) 0x800000LL, (long long) 0x1000000LL, (long long) 0x2000000LL, (long long) 0x4000000LL, (long long) 0x8000000LL, (long long) 0x10000000LL, (long long) 0x20000000LL, (long long) 0x40000000LL, (long long) 0x80000000LL, (long long) 0x100000000LL, (long long) 0x200000000LL, (long long) 0x400000000LL, (long long) 0x800000000LL, (long long) 0x1000000000LL, (long long) 0x2000000000LL, (long long) 0x4000000000LL, (long long) 0x8000000000LL, (long long) 0x10000000000LL, (long long) 0x20000000000LL, (long long) 0x40000000000LL, (long long) 0x80000000000LL, (long long) 0x100000000000LL, (long long) 0x200000000000LL, (long long) 0x400000000000LL, (long long) 0x800000000000LL, (long long) 0x1000000000000LL, (long long) 0x2000000000000LL, (long long) 0x4000000000000LL, (long long) 0x8000000000000LL, (long long) 0x10000000000000LL, (long long) 0x20000000000000LL, (long long) 0x40000000000000LL, (long long) 0x80000000000000LL, (long long) 0x100000000000000LL, (long long) 0x200000000000000LL, (long long) 0x400000000000000LL, (long long) 0x800000000000000LL, (long long) 0x1000000000000000LL, (long long) 0x2000000000000000LL, (long long) 0x4000000000000000LL, -0x7fffffffffffffffLL - 1 } count:64]);
  }
}

- (id)copyWithZone:(NSZone *)zone {
  return [[self clone] retain];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&bits_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilBitSet *typedCopy = (JavaUtilBitSet *) copy;
  typedCopy.bits = bits_;
  typedCopy.needClear_ = needClear__;
  typedCopy.actualArrayLength = actualArrayLength_;
  typedCopy.isLengthActual = isLengthActual_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:bits_ name:@"bits"]];
  return result;
}

@end
