//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/util/IdentityHashMap.java
//
//  Created by retechretech on 13-4-26.
//

#import "IOSObjectArray.h"
#import "java/lang/CloneNotSupportedException.h"
#import "java/lang/IllegalArgumentException.h"
#import "java/lang/IllegalStateException.h"
#import "java/lang/System.h"
#import "java/util/Collection.h"
#import "java/util/ConcurrentModificationException.h"
#import "java/util/IdentityHashMap.h"
#import "java/util/Iterator.h"
#import "java/util/Map.h"
#import "java/util/MapEntry.h"
#import "java/util/NoSuchElementException.h"
#import "java/util/Set.h"

@implementation JavaUtilIdentityHashMap

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaUtilIdentityHashMap_NULL_OBJECT_ name:@"JavaUtilIdentityHashMap_NULL_OBJECT_"]];
  return result;
}

static id JavaUtilIdentityHashMap_NULL_OBJECT_;

- (IOSObjectArray *)elementData {
  return elementData_;
}
- (void)setElementData:(IOSObjectArray *)elementData {
  JreOperatorRetainedAssign(&elementData_, elementData);
}
@synthesize elementData = elementData_;
@synthesize size_ = size__;
@synthesize threshold = threshold_;
@synthesize modCount = modCount_;

+ (id)NULL_OBJECT {
  return JavaUtilIdentityHashMap_NULL_OBJECT_;
}

- (id)init {
  return JreMemDebugAdd([self initJavaUtilIdentityHashMapWithInt:JavaUtilIdentityHashMap_DEFAULT_MAX_SIZE]);
}

- (id)initJavaUtilIdentityHashMapWithInt:(int)maxSize {
  if ((self = [super init])) {
    modCount_ = 0;
    if (maxSize >= 0) {
      self.size_ = 0;
      threshold_ = [self getThresholdWithInt:maxSize];
      JreOperatorRetainedAssign(&elementData_, [self newElementArrayWithInt:[self computeElementArraySize]]);
    }
    else {
      @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithInt:(int)maxSize {
  return [self initJavaUtilIdentityHashMapWithInt:maxSize];
}

- (int)getThresholdWithInt:(int)maxSize {
  return maxSize > 3 ? maxSize : 3;
}

- (int)computeElementArraySize {
  int arraySize = (int) (((long long int) threshold_ * 10000) / JavaUtilIdentityHashMap_loadFactor) * 2;
  return arraySize < 0 ? -arraySize : arraySize;
}

- (IOSObjectArray *)newElementArrayWithInt:(int)s OBJC_METHOD_FAMILY_NONE {
  return [[[IOSObjectArray alloc] initWithLength:s type:[IOSClass classWithClass:[NSObject class]]] autorelease];
}

- (id)initWithJavaUtilMap:(id<JavaUtilMap>)map {
  if ((self = [self initJavaUtilIdentityHashMapWithInt:[((id<JavaUtilMap>) NIL_CHK(map)) size] < 6 ? 11 : [((id<JavaUtilMap>) NIL_CHK(map)) size] * 2])) {
    [self putAllImplWithJavaUtilMap:map];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)massageValueWithId:(id)value {
  return (id) ((value == JavaUtilIdentityHashMap_NULL_OBJECT_) ? nil : value);
}

- (void)clear {
  size__ = 0;
  for (int i = 0; i < (int) [((IOSObjectArray *) NIL_CHK(elementData_)) count]; i++) {
    [((IOSObjectArray *) NIL_CHK(elementData_)) replaceObjectAtIndex:i withObject:nil];
  }
  modCount_++;
}

- (BOOL)containsKeyWithId:(id)key {
  if (key == nil) {
    key = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  int index = [JavaUtilIdentityHashMap findIndexWithId:key withNSObjectArray:elementData_];
  return [((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:index] == key;
}

- (BOOL)containsValueWithId:(id)value {
  if (value == nil) {
    value = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  for (int i = 1; i < (int) [((IOSObjectArray *) NIL_CHK(elementData_)) count]; i = i + 2) {
    if ([((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:i] == value) {
      return YES;
    }
  }
  return NO;
}

- (id)getWithId:(id)key {
  if (key == nil) {
    key = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  int index = [JavaUtilIdentityHashMap findIndexWithId:key withNSObjectArray:elementData_];
  if ([((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:index] == key) {
    id result = [((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:index + 1];
    return [self massageValueWithId:result];
  }
  return nil;
}

- (JavaUtilIdentityHashMap_IdentityHashMapEntry *)getEntryWithId:(id)key {
  if (key == nil) {
    key = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  int index = [JavaUtilIdentityHashMap findIndexWithId:key withNSObjectArray:elementData_];
  if ([((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:index] == key) {
    return [self getEntryWithInt:index];
  }
  return nil;
}

- (JavaUtilIdentityHashMap_IdentityHashMapEntry *)getEntryWithInt:(int)index {
  return [[[JavaUtilIdentityHashMap_IdentityHashMapEntry alloc] initWithId:(id) [((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:index] withId:(id) [((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:index + 1] withNSObjectArray:elementData_] autorelease];
}

+ (int)findIndexWithId:(id)key
     withNSObjectArray:(IOSObjectArray *)array {
  int length = (int) [((IOSObjectArray *) NIL_CHK(array)) count];
  int index = [JavaUtilIdentityHashMap getModuloHashWithId:key withInt:length];
  int last = (index + length - 2) % length;
  while (index != last) {
    if ([((IOSObjectArray *) NIL_CHK(array)) objectAtIndex:index] == key || ([((IOSObjectArray *) NIL_CHK(array)) objectAtIndex:index] == nil)) {
      break;
    }
    index = (index + 2) % length;
  }
  return index;
}

+ (int)getModuloHashWithId:(id)key
                   withInt:(int)length {
  return (([JavaLangSystem identityHashCodeWithId:key] & (int) 0x7FFFFFFF) % (length / 2)) * 2;
}

- (id)putWithId:(id)key
         withId:(id)value {
  id _key = key;
  id _value = value;
  if (_key == nil) {
    _key = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  if (_value == nil) {
    _value = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  int index = [JavaUtilIdentityHashMap findIndexWithId:_key withNSObjectArray:elementData_];
  if ([((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:index] != _key) {
    modCount_++;
    if (++size__ > threshold_) {
      [self rehash];
      index = [JavaUtilIdentityHashMap findIndexWithId:_key withNSObjectArray:elementData_];
    }
    [((IOSObjectArray *) NIL_CHK(elementData_)) replaceObjectAtIndex:index withObject:_key];
    [((IOSObjectArray *) NIL_CHK(elementData_)) replaceObjectAtIndex:index + 1 withObject:nil];
  }
  id result = [((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:index + 1];
  [((IOSObjectArray *) NIL_CHK(elementData_)) replaceObjectAtIndex:index + 1 withObject:_value];
  return [self massageValueWithId:result];
}

- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)map {
  [self putAllImplWithJavaUtilMap:map];
}

- (void)rehash {
  int newlength = (int) [((IOSObjectArray *) NIL_CHK(elementData_)) count] << 1;
  if (newlength == 0) {
    newlength = 1;
  }
  IOSObjectArray *newData = [self newElementArrayWithInt:newlength];
  for (int i = 0; i < (int) [((IOSObjectArray *) NIL_CHK(elementData_)) count]; i = i + 2) {
    id key = [((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:i];
    if (key != nil) {
      int index = [JavaUtilIdentityHashMap findIndexWithId:key withNSObjectArray:newData];
      [((IOSObjectArray *) NIL_CHK(newData)) replaceObjectAtIndex:index withObject:key];
      [((IOSObjectArray *) NIL_CHK(newData)) replaceObjectAtIndex:index + 1 withObject:[((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:i + 1]];
    }
  }
  JreOperatorRetainedAssign(&elementData_, newData);
  [self computeMaxSize];
}

- (void)computeMaxSize {
  threshold_ = (int) ((long long int) ((int) [((IOSObjectArray *) NIL_CHK(elementData_)) count] / 2) * JavaUtilIdentityHashMap_loadFactor / 10000);
}

- (id)removeWithId:(id)key {
  if (key == nil) {
    key = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  BOOL hashedOk;
  int index, next, hash_;
  id result, object;
  index = next = [JavaUtilIdentityHashMap findIndexWithId:key withNSObjectArray:elementData_];
  if ([((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:index] != key) {
    return nil;
  }
  result = [((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:index + 1];
  int length = (int) [((IOSObjectArray *) NIL_CHK(elementData_)) count];
  while (YES) {
    next = (next + 2) % length;
    object = [((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:next];
    if (object == nil) {
      break;
    }
    hash_ = [JavaUtilIdentityHashMap getModuloHashWithId:object withInt:length];
    hashedOk = hash_ > index;
    if (next < index) {
      hashedOk = hashedOk || (hash_ <= next);
    }
    else {
      hashedOk = hashedOk && (hash_ <= next);
    }
    if (!hashedOk) {
      [((IOSObjectArray *) NIL_CHK(elementData_)) replaceObjectAtIndex:index withObject:object];
      [((IOSObjectArray *) NIL_CHK(elementData_)) replaceObjectAtIndex:index + 1 withObject:[((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:next + 1]];
      index = next;
    }
  }
  size__--;
  modCount_++;
  [((IOSObjectArray *) NIL_CHK(elementData_)) replaceObjectAtIndex:index withObject:nil];
  [((IOSObjectArray *) NIL_CHK(elementData_)) replaceObjectAtIndex:index + 1 withObject:nil];
  return [self massageValueWithId:result];
}

- (id<JavaUtilSet>)entrySet {
  return [[[JavaUtilIdentityHashMap_IdentityHashMapEntrySet alloc] initWithJavaUtilIdentityHashMap:self] autorelease];
}

- (id<JavaUtilSet>)keySet {
  if (keySet__ == nil) {
    JreOperatorRetainedAssign(&keySet__, [[[JavaUtilIdentityHashMap_KeySet alloc] initWithJavaUtilIdentityHashMap:self] autorelease]);
  }
  return keySet__;
}

- (id<JavaUtilCollection>)values {
  if (valuesCollection_ == nil) {
    JreOperatorRetainedAssign(&valuesCollection_, [[[JavaUtilIdentityHashMap_ValuesCollection alloc] initWithJavaUtilIdentityHashMap:self] autorelease]);
  }
  return valuesCollection_;
}

- (BOOL)isEqual:(id)object {
  if (self == object) {
    return YES;
  }
  if ([object conformsToProtocol: @protocol(JavaUtilMap)]) {
    id<JavaUtilMap> map = (id<JavaUtilMap>) object;
    if ([self size] != [((id<JavaUtilMap>) NIL_CHK(map)) size]) {
      return NO;
    }
    id<JavaUtilSet> set = [self entrySet];
    return [((id<JavaUtilSet>) NIL_CHK(set)) isEqual:((id<JavaUtilSet>) [((id<JavaUtilMap>) NIL_CHK(map)) entrySet])];
  }
  return NO;
}

- (id)clone {
  @try {
    JavaUtilIdentityHashMap *cloneHashMap = (JavaUtilIdentityHashMap *) [super clone];
    ((JavaUtilIdentityHashMap *) NIL_CHK(cloneHashMap)).elementData = [self newElementArrayWithInt:(int) [((IOSObjectArray *) NIL_CHK(elementData_)) count]];
    [JavaLangSystem arraycopyWithId:elementData_ withInt:0 withId:((JavaUtilIdentityHashMap *) NIL_CHK(cloneHashMap)).elementData withInt:0 withInt:(int) [((IOSObjectArray *) NIL_CHK(elementData_)) count]];
    return cloneHashMap;
  }
  @catch (JavaLangCloneNotSupportedException *e) {
    return nil;
  }
}

- (BOOL)isEmpty {
  return size__ == 0;
}

- (int)size {
  return size__;
}

- (void)putAllImplWithJavaUtilMap:(id<JavaUtilMap>)map {
  if (((id<JavaUtilSet>) [((id<JavaUtilMap>) NIL_CHK(map)) entrySet]) != nil) {
    [super putAllWithJavaUtilMap:map];
  }
}

+ (void)initialize {
  if (self == [JavaUtilIdentityHashMap class]) {
    JreOperatorRetainedAssign(&JavaUtilIdentityHashMap_NULL_OBJECT_, [[[NSObject alloc] init] autorelease]);
  }
}

- (id)copyWithZone:(NSZone *)zone {
  return [[self clone] retain];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&elementData_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilIdentityHashMap *typedCopy = (JavaUtilIdentityHashMap *) copy;
  typedCopy.elementData = elementData_;
  typedCopy.size_ = size__;
  typedCopy.threshold = threshold_;
  typedCopy.modCount = modCount_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:elementData_ name:@"elementData"]];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_IdentityHashMapEntry

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)iKey {
  return iKey_;
}
- (void)setIKey:(id)iKey {
  JreOperatorRetainedAssign(&iKey_, iKey);
}
@synthesize iKey = iKey_;
- (IOSObjectArray *)elementData {
  return elementData_;
}
- (void)setElementData:(IOSObjectArray *)elementData {
  JreOperatorRetainedAssign(&elementData_, elementData);
}
@synthesize elementData = elementData_;

- (id)initWithId:(id)theKey
          withId:(id)theValue
withNSObjectArray:(IOSObjectArray *)elementData {
  if ((self = [super initWithId:(id) theKey == [JavaUtilIdentityHashMap NULL_OBJECT] ? nil : theKey withId:(id) theValue == [JavaUtilIdentityHashMap NULL_OBJECT] ? nil : theValue])) {
    JreOperatorRetainedAssign(&iKey_, theKey);
    self.elementData = elementData;
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)clone {
  return (id) [super clone];
}

- (BOOL)isEqual:(id)object {
  if (self == object) {
    return YES;
  }
  if ([object conformsToProtocol: @protocol(JavaUtilMap_Entry)]) {
    id<JavaUtilMap_Entry> entry = (id<JavaUtilMap_Entry>) object;
    return (key_ == [((id<JavaUtilMap_Entry>) NIL_CHK(entry)) getKey]) && (value_ == [((id<JavaUtilMap_Entry>) NIL_CHK(entry)) getValue]);
  }
  return NO;
}

- (NSUInteger)hash {
  return [JavaLangSystem identityHashCodeWithId:key_] ^ [JavaLangSystem identityHashCodeWithId:value_];
}

- (NSString *)description {
  return [NSString stringWithFormat:@"%@=%@", key_, value_];
}

- (id)setValueWithId:(id)object {
  int index = [JavaUtilIdentityHashMap findIndexWithId:iKey_ withNSObjectArray:elementData_];
  if ([((IOSObjectArray *) NIL_CHK(elementData_)) objectAtIndex:index] == key_) {
    [((IOSObjectArray *) NIL_CHK(elementData_)) replaceObjectAtIndex:index + 1 withObject:object];
  }
  return (id) [super setValueWithId:object];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&elementData_, nil);
  JreOperatorRetainedAssign(&iKey_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilIdentityHashMap_IdentityHashMapEntry *typedCopy = (JavaUtilIdentityHashMap_IdentityHashMapEntry *) copy;
  typedCopy.iKey = iKey_;
  typedCopy.elementData = elementData_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:iKey_ name:@"iKey"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:elementData_ name:@"elementData"]];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_IdentityHashMapIterator

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

@synthesize position = position_;
@synthesize lastPosition = lastPosition_;
- (JavaUtilIdentityHashMap *)associatedMap {
  return associatedMap_;
}
- (void)setAssociatedMap:(JavaUtilIdentityHashMap *)associatedMap {
  JreOperatorRetainedAssign(&associatedMap_, associatedMap);
}
@synthesize associatedMap = associatedMap_;
@synthesize expectedModCount = expectedModCount_;
- (id<JavaUtilMapEntry_Type>)type {
  return type_;
}
- (void)setType:(id<JavaUtilMapEntry_Type>)type {
  JreOperatorRetainedAssign(&type_, type);
}
@synthesize type = type_;
@synthesize canRemove = canRemove_;

- (id)initWithJavaUtilMapEntry_Type:(id<JavaUtilMapEntry_Type>)value
        withJavaUtilIdentityHashMap:(JavaUtilIdentityHashMap *)hm {
  if ((self = [super init])) {
    position_ = 0;
    lastPosition_ = 0;
    canRemove_ = NO;
    JreOperatorRetainedAssign(&associatedMap_, hm);
    JreOperatorRetainedAssign(&type_, value);
    expectedModCount_ = ((JavaUtilIdentityHashMap *) NIL_CHK(hm)).modCount;
    JreMemDebugAdd(self);
  }
  return self;
}

- (BOOL)hasNext {
  while (position_ < (int) [((IOSObjectArray *) NIL_CHK(associatedMap_.elementData)) count]) {
    if ([((IOSObjectArray *) NIL_CHK(associatedMap_.elementData)) objectAtIndex:position_] == nil) {
      position_ += 2;
    }
    else {
      return YES;
    }
  }
  return NO;
}

- (void)checkConcurrentMod {
  if (expectedModCount_ != ((JavaUtilIdentityHashMap *) NIL_CHK(associatedMap_)).modCount) {
    @throw [[[JavaUtilConcurrentModificationException alloc] init] autorelease];
  }
}

- (id)next {
  [self checkConcurrentMod];
  if (![self hasNext]) {
    @throw [[[JavaUtilNoSuchElementException alloc] init] autorelease];
  }
  JavaUtilIdentityHashMap_IdentityHashMapEntry *result = ((JavaUtilIdentityHashMap_IdentityHashMapEntry *) [((JavaUtilIdentityHashMap *) NIL_CHK(associatedMap_)) getEntryWithInt:position_]);
  lastPosition_ = position_;
  position_ += 2;
  canRemove_ = YES;
  return [((id<JavaUtilMapEntry_Type>) NIL_CHK(type_)) getWithJavaUtilMapEntry:result];
}

- (void)remove {
  [self checkConcurrentMod];
  if (!canRemove_) {
    @throw [[[JavaLangIllegalStateException alloc] init] autorelease];
  }
  canRemove_ = NO;
  [((JavaUtilIdentityHashMap *) NIL_CHK(associatedMap_)) removeWithId:[((IOSObjectArray *) NIL_CHK(associatedMap_.elementData)) objectAtIndex:lastPosition_]];
  position_ = lastPosition_;
  expectedModCount_++;
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&type_, nil);
  JreOperatorRetainedAssign(&associatedMap_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilIdentityHashMap_IdentityHashMapIterator *typedCopy = (JavaUtilIdentityHashMap_IdentityHashMapIterator *) copy;
  typedCopy.position = position_;
  typedCopy.lastPosition = lastPosition_;
  typedCopy.associatedMap = associatedMap_;
  typedCopy.expectedModCount = expectedModCount_;
  typedCopy.type = type_;
  typedCopy.canRemove = canRemove_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:associatedMap_ name:@"associatedMap"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:type_ name:@"type"]];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_IdentityHashMapEntrySet

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (JavaUtilIdentityHashMap *)associatedMap {
  return associatedMap_;
}
- (void)setAssociatedMap:(JavaUtilIdentityHashMap *)associatedMap {
  JreOperatorRetainedAssign(&associatedMap_, associatedMap);
}
@synthesize associatedMap = associatedMap_;

- (id)initWithJavaUtilIdentityHashMap:(JavaUtilIdentityHashMap *)hm {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&associatedMap_, hm);
    JreMemDebugAdd(self);
  }
  return self;
}

- (JavaUtilIdentityHashMap *)hashMap {
  return associatedMap_;
}

- (int)size {
  return ((JavaUtilIdentityHashMap *) NIL_CHK(associatedMap_)).size_;
}

- (void)clear {
  [((JavaUtilIdentityHashMap *) NIL_CHK(associatedMap_)) clear];
}

- (BOOL)removeWithId:(id)object {
  if ([self containsWithId:object]) {
    [((JavaUtilIdentityHashMap *) NIL_CHK(associatedMap_)) removeWithId:[((id<JavaUtilMap_Entry>) object) getKey]];
    return YES;
  }
  return NO;
}

- (BOOL)containsWithId:(id)object {
  if ([object conformsToProtocol: @protocol(JavaUtilMap_Entry)]) {
    JavaUtilIdentityHashMap_IdentityHashMapEntry *entry = [((JavaUtilIdentityHashMap *) NIL_CHK(associatedMap_)) getEntryWithId:[((id<JavaUtilMap_Entry>) object) getKey]];
    return entry != nil && [((JavaUtilIdentityHashMap_IdentityHashMapEntry *) NIL_CHK(entry)) isEqual:object];
  }
  return NO;
}

- (id<JavaUtilIterator>)iterator {
  return [[[JavaUtilIdentityHashMap_IdentityHashMapIterator alloc] initWithJavaUtilMapEntry_Type:[[[JavaUtilIdentityHashMap_IdentityHashMapEntrySet_$1 alloc] init] autorelease] withJavaUtilIdentityHashMap:associatedMap_] autorelease];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&associatedMap_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilIdentityHashMap_IdentityHashMapEntrySet *typedCopy = (JavaUtilIdentityHashMap_IdentityHashMapEntrySet *) copy;
  typedCopy.associatedMap = associatedMap_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:associatedMap_ name:@"associatedMap"]];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_IdentityHashMapEntrySet_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id<JavaUtilMap_Entry>)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return entry;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

@end
@implementation JavaUtilIdentityHashMap_KeySet

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (JavaUtilIdentityHashMap *)this$0 {
  return this$0_;
}
@synthesize this$0 = this$0_;

- (BOOL)containsWithId:(id)object {
  return [this$0_ containsKeyWithId:object];
}

- (int)size {
  return [this$0_ size];
}

- (void)clear {
  [this$0_ clear];
}

- (BOOL)removeWithId:(id)key {
  if ([this$0_ containsKeyWithId:key]) {
    [this$0_ removeWithId:key];
    return YES;
  }
  return NO;
}

- (id<JavaUtilIterator>)iterator {
  return [[[JavaUtilIdentityHashMap_IdentityHashMapIterator alloc] initWithJavaUtilMapEntry_Type:[[[JavaUtilIdentityHashMap_KeySet_$1 alloc] init] autorelease] withJavaUtilIdentityHashMap:this$0_] autorelease];
}

- (id)initWithJavaUtilIdentityHashMap:(JavaUtilIdentityHashMap *)outer$ {
  if ((self = [super init])) {
    this$0_ = outer$;
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilIdentityHashMap_KeySet *typedCopy = (JavaUtilIdentityHashMap_KeySet *) copy;
  typedCopy.this$0 = this$0_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_KeySet_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return ((JavaUtilMapEntry *) NIL_CHK(entry)).key;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

@end
@implementation JavaUtilIdentityHashMap_ValuesCollection

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (JavaUtilIdentityHashMap *)this$0 {
  return this$0_;
}
@synthesize this$0 = this$0_;

- (BOOL)containsWithId:(id)object {
  return [this$0_ containsValueWithId:object];
}

- (int)size {
  return [this$0_ size];
}

- (void)clear {
  [this$0_ clear];
}

- (id<JavaUtilIterator>)iterator {
  return [[[JavaUtilIdentityHashMap_IdentityHashMapIterator alloc] initWithJavaUtilMapEntry_Type:[[[JavaUtilIdentityHashMap_ValuesCollection_$1 alloc] init] autorelease] withJavaUtilIdentityHashMap:this$0_] autorelease];
}

- (BOOL)removeWithId:(id)object {
  id<JavaUtilIterator> it = [self iterator];
  while ([((id<JavaUtilIterator>) NIL_CHK(it)) hasNext]) {
    if (object == [((id<JavaUtilIterator>) NIL_CHK(it)) next]) {
      [((id<JavaUtilIterator>) NIL_CHK(it)) remove];
      return YES;
    }
  }
  return NO;
}

- (id)initWithJavaUtilIdentityHashMap:(JavaUtilIdentityHashMap *)outer$ {
  if ((self = [super init])) {
    this$0_ = outer$;
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilIdentityHashMap_ValuesCollection *typedCopy = (JavaUtilIdentityHashMap_ValuesCollection *) copy;
  typedCopy.this$0 = this$0_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_ValuesCollection_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return ((JavaUtilMapEntry *) NIL_CHK(entry)).value;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

@end
