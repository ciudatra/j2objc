//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/util/EnumMap.java
//
//  Created by retechretech on 13-4-24.
//

#import "IOSBooleanArray.h"
#import "IOSClass.h"
#import "IOSObjectArray.h"
#import "java/lang/ClassCastException.h"
#import "java/lang/CloneNotSupportedException.h"
#import "java/lang/Enum.h"
#import "java/lang/IllegalArgumentException.h"
#import "java/lang/IllegalStateException.h"
#import "java/lang/NullPointerException.h"
#import "java/lang/StringBuilder.h"
#import "java/util/Arrays.h"
#import "java/util/Collection.h"
#import "java/util/EnumMap.h"
#import "java/util/Iterator.h"
#import "java/util/Map.h"
#import "java/util/MapEntry.h"
#import "java/util/NoSuchElementException.h"
#import "java/util/Set.h"

@implementation JavaUtilEnumMap

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (IOSClass *)keyType {
  return keyType_;
}
- (void)setKeyType:(IOSClass *)keyType {
  JreOperatorRetainedAssign(&keyType_, keyType);
}
@synthesize keyType = keyType_;
- (IOSObjectArray *)keys {
  return keys_;
}
- (void)setKeys:(IOSObjectArray *)keys {
  JreOperatorRetainedAssign(&keys_, keys);
}
@synthesize keys = keys_;
- (IOSObjectArray *)values_ {
  return values__;
}
- (void)setValues_:(IOSObjectArray *)values_ {
  JreOperatorRetainedAssign(&values__, values_);
}
@synthesize values_ = values__;
- (IOSBooleanArray *)hasMapping {
  return hasMapping_;
}
- (void)setHasMapping:(IOSBooleanArray *)hasMapping {
  JreOperatorRetainedAssign(&hasMapping_, hasMapping);
}
@synthesize hasMapping = hasMapping_;
@synthesize mappingsCount = mappingsCount_;
@synthesize enumSize = enumSize_;
- (JavaUtilEnumMap_EnumMapEntrySet *)entrySet_ {
  return entrySet__;
}
- (void)setEntrySet_:(JavaUtilEnumMap_EnumMapEntrySet *)entrySet_ {
  JreOperatorRetainedAssign(&entrySet__, entrySet_);
}
@synthesize entrySet_ = entrySet__;
- (id<JavaUtilCollection>)valuesCollection_EnumMap {
  return valuesCollection_EnumMap_;
}
- (void)setValuesCollection_EnumMap:(id<JavaUtilCollection>)valuesCollection_EnumMap {
  JreOperatorRetainedAssign(&valuesCollection_EnumMap_, valuesCollection_EnumMap);
}
@synthesize valuesCollection_EnumMap = valuesCollection_EnumMap_;

- (id)initWithIOSClass:(IOSClass *)keyType {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&entrySet__, nil);
    [self initializationWithIOSClass:keyType];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaUtilEnumMap:(JavaUtilEnumMap *)map {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&entrySet__, nil);
    [self initializationWithJavaUtilEnumMap:map];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaUtilMap:(id<JavaUtilMap>)map {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&entrySet__, nil);
    if ([(id) map isKindOfClass:[JavaUtilEnumMap class]]) {
      [self initializationWithJavaUtilEnumMap:(JavaUtilEnumMap *) map];
    }
    else {
      if (0 == [((id<JavaUtilMap>) NIL_CHK(map)) size]) {
        @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
      }
      id<JavaUtilIterator> iter = ((id<JavaUtilIterator>) [((id<JavaUtilSet>) [((id<JavaUtilMap>) NIL_CHK(map)) keySet]) iterator]);
      JavaLangEnum *enumKey = [((id<JavaUtilIterator>) NIL_CHK(iter)) next];
      IOSClass *clazz = [NIL_CHK(enumKey) getClass];
      if ([NIL_CHK(clazz) isEnum]) {
        [self initializationWithIOSClass:clazz];
      }
      else {
        [self initializationWithIOSClass:[NIL_CHK(clazz) getSuperclass]];
      }
      [self putAllImplWithJavaUtilMap:map];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)clear {
  [JavaUtilArrays fillWithNSObjectArray:values__ withId:nil];
  [JavaUtilArrays fillWithJavaLangBooleanArray:hasMapping_ withBOOL:NO];
  mappingsCount_ = 0;
}

- (JavaUtilEnumMap *)clone {
  @try {
    JavaUtilEnumMap *enumMap = (JavaUtilEnumMap *) [super clone];
    [((JavaUtilEnumMap *) NIL_CHK(enumMap)) initializationWithJavaUtilEnumMap:self];
    return enumMap;
  }
  @catch (JavaLangCloneNotSupportedException *e) {
    return nil;
  }
}

- (BOOL)containsKeyWithId:(id)key {
  if ([self isValidKeyTypeWithId:key]) {
    int keyOrdinal = [((JavaLangEnum *) key) ordinal];
    return [((IOSBooleanArray *) NIL_CHK(hasMapping_)) booleanAtIndex:keyOrdinal];
  }
  return NO;
}

- (BOOL)containsValueWithId:(id)value {
  if (nil == value) {
    for (int i = 0; i < enumSize_; i++) {
      if ([((IOSBooleanArray *) NIL_CHK(hasMapping_)) booleanAtIndex:i] && nil == [((IOSObjectArray *) NIL_CHK(values__)) objectAtIndex:i]) {
        return YES;
      }
    }
  }
  else {
    for (int i = 0; i < enumSize_; i++) {
      if ([((IOSBooleanArray *) NIL_CHK(hasMapping_)) booleanAtIndex:i] && [value isEqual:[((IOSObjectArray *) NIL_CHK(values__)) objectAtIndex:i]]) {
        return YES;
      }
    }
  }
  return NO;
}

- (id<JavaUtilSet>)entrySet {
  if (nil == entrySet__) {
    JreOperatorRetainedAssign(&entrySet__, [[[JavaUtilEnumMap_EnumMapEntrySet alloc] initWithJavaUtilEnumMap:self] autorelease]);
  }
  return entrySet__;
}

- (BOOL)isEqual:(id)object {
  if (self == object) {
    return YES;
  }
  if (!([object isKindOfClass:[JavaUtilEnumMap class]])) {
    return (BOOL) [super isEqual:object];
  }
  JavaUtilEnumMap *enumMap = (JavaUtilEnumMap *) object;
  if (keyType_ != ((JavaUtilEnumMap *) NIL_CHK(enumMap)).keyType || [self size] != [((JavaUtilEnumMap *) NIL_CHK(enumMap)) size]) {
    return NO;
  }
  return [JavaUtilArrays equalsWithJavaLangBooleanArray:hasMapping_ withJavaLangBooleanArray:((JavaUtilEnumMap *) NIL_CHK(enumMap)).hasMapping] && [JavaUtilArrays equalsWithNSObjectArray:values__ withNSObjectArray:((JavaUtilEnumMap *) NIL_CHK(enumMap)).values_];
}

- (id)getWithId:(id)key {
  if (![self isValidKeyTypeWithId:key]) {
    return nil;
  }
  int keyOrdinal = [((JavaLangEnum *) key) ordinal];
  return (id) [((IOSObjectArray *) NIL_CHK(values__)) objectAtIndex:keyOrdinal];
}

- (id<JavaUtilSet>)keySet {
  if (nil == keySet__) {
    JreOperatorRetainedAssign(&keySet__, [[[JavaUtilEnumMap_EnumMapKeySet alloc] initWithJavaUtilEnumMap:self] autorelease]);
  }
  return keySet__;
}

- (id)putWithId:(JavaLangEnum *)key
         withId:(id)value {
  return [self putImplWithId:key withId:value];
}

- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)map {
  [self putAllImplWithJavaUtilMap:map];
}

- (id)removeWithId:(id)key {
  if (![self isValidKeyTypeWithId:key]) {
    return nil;
  }
  int keyOrdinal = [((JavaLangEnum *) key) ordinal];
  if ([((IOSBooleanArray *) NIL_CHK(hasMapping_)) booleanAtIndex:keyOrdinal]) {
    [((IOSBooleanArray *) NIL_CHK(hasMapping_)) replaceBooleanAtIndex:keyOrdinal withBoolean:NO];
    mappingsCount_--;
  }
  id oldValue = (id) [((IOSObjectArray *) NIL_CHK(values__)) objectAtIndex:keyOrdinal];
  [((IOSObjectArray *) NIL_CHK(values__)) replaceObjectAtIndex:keyOrdinal withObject:nil];
  return oldValue;
}

- (int)size {
  return mappingsCount_;
}

- (id<JavaUtilCollection>)values {
  if (nil == valuesCollection_EnumMap_) {
    JreOperatorRetainedAssign(&valuesCollection_EnumMap_, [[[JavaUtilEnumMap_EnumMapValueCollection alloc] initWithJavaUtilEnumMap:self] autorelease]);
  }
  return valuesCollection_EnumMap_;
}

- (BOOL)isValidKeyTypeWithId:(id)key {
  if (nil != key && [NIL_CHK(keyType_) isInstance:key]) {
    return YES;
  }
  return NO;
}

- (void)initializationWithJavaUtilEnumMap:(JavaUtilEnumMap *)enumMap OBJC_METHOD_FAMILY_NONE {
  JreOperatorRetainedAssign(&keyType_, ((JavaUtilEnumMap *) NIL_CHK(enumMap)).keyType);
  JreOperatorRetainedAssign(&keys_, ((JavaUtilEnumMap *) NIL_CHK(enumMap)).keys);
  enumSize_ = ((JavaUtilEnumMap *) NIL_CHK(enumMap)).enumSize;
  JreOperatorRetainedAssign(&values__, [((IOSObjectArray *) NIL_CHK(enumMap.values_)) clone]);
  JreOperatorRetainedAssign(&hasMapping_, [((IOSBooleanArray *) NIL_CHK(enumMap.hasMapping)) clone]);
  mappingsCount_ = ((JavaUtilEnumMap *) NIL_CHK(enumMap)).mappingsCount;
}

- (void)initializationWithIOSClass:(IOSClass *)type OBJC_METHOD_FAMILY_NONE {
  JreOperatorRetainedAssign(&keyType_, type);
  JreOperatorRetainedAssign(&keys_, [NIL_CHK(keyType_) getEnumConstants]);
  enumSize_ = (int) [((IOSObjectArray *) NIL_CHK(keys_)) count];
  JreOperatorRetainedAssign(&values__, [[[IOSObjectArray alloc] initWithLength:enumSize_ type:[IOSClass classWithClass:[NSObject class]]] autorelease]);
  JreOperatorRetainedAssign(&hasMapping_, [[[IOSBooleanArray alloc] initWithLength:enumSize_] autorelease]);
}

- (void)putAllImplWithJavaUtilMap:(id<JavaUtilMap>)map {
  id<JavaUtilIterator> iter = [((id<JavaUtilSet>) [((id<JavaUtilMap>) NIL_CHK(map)) entrySet]) iterator];
  while ([((id<JavaUtilIterator>) NIL_CHK(iter)) hasNext]) {
    id<JavaUtilMap_Entry> entry = (id<JavaUtilMap_Entry>) [((id<JavaUtilIterator>) NIL_CHK(iter)) next];
    [self putImplWithId:(JavaLangEnum *) [((id<JavaUtilMap_Entry>) NIL_CHK(entry)) getKey] withId:(id) [((id<JavaUtilMap_Entry>) NIL_CHK(entry)) getValue]];
  }
}

- (id)putImplWithId:(JavaLangEnum *)key
             withId:(id)value {
  if (nil == key) {
    @throw [[[JavaLangNullPointerException alloc] init] autorelease];
  }
  if (![self isValidKeyTypeWithId:key]) {
    @throw [[[JavaLangClassCastException alloc] init] autorelease];
  }
  int keyOrdinal = [NIL_CHK(key) ordinal];
  if (![((IOSBooleanArray *) NIL_CHK(hasMapping_)) booleanAtIndex:keyOrdinal]) {
    [((IOSBooleanArray *) NIL_CHK(hasMapping_)) replaceBooleanAtIndex:keyOrdinal withBoolean:YES];
    mappingsCount_++;
  }
  id oldValue = (id) [((IOSObjectArray *) NIL_CHK(values__)) objectAtIndex:keyOrdinal];
  [((IOSObjectArray *) NIL_CHK(values__)) replaceObjectAtIndex:keyOrdinal withObject:value];
  return oldValue;
}

- (id)copyWithZone:(NSZone *)zone {
  return [[self clone] retain];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&valuesCollection_EnumMap_, nil);
  JreOperatorRetainedAssign(&entrySet__, nil);
  JreOperatorRetainedAssign(&hasMapping_, nil);
  JreOperatorRetainedAssign(&values__, nil);
  JreOperatorRetainedAssign(&keys_, nil);
  JreOperatorRetainedAssign(&keyType_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilEnumMap *typedCopy = (JavaUtilEnumMap *) copy;
  typedCopy.keyType = keyType_;
  typedCopy.keys = keys_;
  typedCopy.values_ = values__;
  typedCopy.hasMapping = hasMapping_;
  typedCopy.mappingsCount = mappingsCount_;
  typedCopy.enumSize = enumSize_;
  typedCopy.entrySet_ = entrySet__;
  typedCopy.valuesCollection_EnumMap = valuesCollection_EnumMap_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:keyType_ name:@"keyType"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:keys_ name:@"keys"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:values__ name:@"values_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:hasMapping_ name:@"hasMapping"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:entrySet__ name:@"entrySet_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:valuesCollection_EnumMap_ name:@"valuesCollection_EnumMap"]];
  return result;
}

@end
@implementation JavaUtilEnumMap_Entry

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (JavaUtilEnumMap *)enumMap {
  return enumMap_;
}
- (void)setEnumMap:(JavaUtilEnumMap *)enumMap {
  JreOperatorRetainedAssign(&enumMap_, enumMap);
}
@synthesize enumMap = enumMap_;
@synthesize ordinal = ordinal_;

- (id)initWithId:(JavaLangEnum *)theKey
          withId:(id)theValue
withJavaUtilEnumMap:(JavaUtilEnumMap *)em {
  if ((self = [super initWithId:theKey withId:theValue])) {
    JreOperatorRetainedAssign(&enumMap_, em);
    ordinal_ = [((JavaLangEnum *) theKey) ordinal];
    JreMemDebugAdd(self);
  }
  return self;
}

- (BOOL)isEqual:(id)object {
  if (![((IOSBooleanArray *) NIL_CHK(enumMap_.hasMapping)) booleanAtIndex:ordinal_]) {
    return NO;
  }
  BOOL isEqual = NO;
  if ([object conformsToProtocol: @protocol(JavaUtilMap_Entry)]) {
    id<JavaUtilMap_Entry> entry = (id<JavaUtilMap_Entry>) object;
    id enumKey = [((id<JavaUtilMap_Entry>) NIL_CHK(entry)) getKey];
    if ([NIL_CHK(key_) isEqual:enumKey]) {
      id theValue = [((id<JavaUtilMap_Entry>) NIL_CHK(entry)) getValue];
      isEqual = [((IOSObjectArray *) NIL_CHK(enumMap_.values_)) objectAtIndex:ordinal_] == nil ? nil == theValue : [[((IOSObjectArray *) NIL_CHK(enumMap_.values_)) objectAtIndex:ordinal_] isEqual:theValue];
    }
  }
  return isEqual;
}

- (NSUInteger)hash {
  return (((JavaLangEnum *) [((IOSObjectArray *) NIL_CHK(enumMap_.keys)) objectAtIndex:ordinal_]) == nil ? 0 : [((JavaLangEnum *) [((IOSObjectArray *) NIL_CHK(enumMap_.keys)) objectAtIndex:ordinal_]) hash]) ^ ([((IOSObjectArray *) NIL_CHK(enumMap_.values_)) objectAtIndex:ordinal_] == nil ? 0 : [[((IOSObjectArray *) NIL_CHK(enumMap_.values_)) objectAtIndex:ordinal_] hash]);
}

- (JavaLangEnum *)getKey {
  [self checkEntryStatus];
  return (JavaLangEnum *) ((JavaLangEnum *) [((IOSObjectArray *) NIL_CHK(enumMap_.keys)) objectAtIndex:ordinal_]);
}

- (id)getValue {
  [self checkEntryStatus];
  return (id) [((IOSObjectArray *) NIL_CHK(enumMap_.values_)) objectAtIndex:ordinal_];
}

- (id)setValueWithId:(id)value {
  [self checkEntryStatus];
  return [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) putWithId:(JavaLangEnum *) ((JavaLangEnum *) [((IOSObjectArray *) NIL_CHK(enumMap_.keys)) objectAtIndex:ordinal_]) withId:value];
}

- (NSString *)description {
  JavaLangStringBuilder *result = [[[JavaLangStringBuilder alloc] initWithNSString:[((JavaLangEnum *) [((IOSObjectArray *) NIL_CHK(enumMap_.keys)) objectAtIndex:ordinal_]) description]] autorelease];
  [((JavaLangStringBuilder *) NIL_CHK(result)) appendWithNSString:@"="];
  [((JavaLangStringBuilder *) NIL_CHK(result)) appendWithNSString:[[((IOSObjectArray *) NIL_CHK(enumMap_.values_)) objectAtIndex:ordinal_] description]];
  return [((JavaLangStringBuilder *) NIL_CHK(result)) description];
}

- (void)checkEntryStatus {
  if (![((IOSBooleanArray *) NIL_CHK(enumMap_.hasMapping)) booleanAtIndex:ordinal_]) {
    @throw [[[JavaLangIllegalStateException alloc] init] autorelease];
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&enumMap_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilEnumMap_Entry *typedCopy = (JavaUtilEnumMap_Entry *) copy;
  typedCopy.enumMap = enumMap_;
  typedCopy.ordinal = ordinal_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:enumMap_ name:@"enumMap"]];
  return result;
}

@end
@implementation JavaUtilEnumMap_EnumMapKeySet

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (JavaUtilEnumMap *)enumMap {
  return enumMap_;
}
@synthesize enumMap = enumMap_;

- (id)initWithJavaUtilEnumMap:(JavaUtilEnumMap *)em {
  if ((self = [super init])) {
    enumMap_ = em;
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)clear {
  [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) clear];
}

- (BOOL)containsWithId:(id)object {
  return [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) containsKeyWithId:object];
}

- (id<JavaUtilIterator>)iterator {
  return [[[JavaUtilEnumMap_EnumMapIterator alloc] initWithJavaUtilMapEntry_Type:[[[JavaUtilEnumMap_EnumMapKeySet_$1 alloc] init] autorelease] withJavaUtilEnumMap:enumMap_] autorelease];
}

- (BOOL)removeWithId:(id)object {
  if ([self containsWithId:object]) {
    [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) removeWithId:object];
    return YES;
  }
  return NO;
}

- (int)size {
  return [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) size];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilEnumMap_EnumMapKeySet *typedCopy = (JavaUtilEnumMap_EnumMapKeySet *) copy;
  typedCopy.enumMap = enumMap_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  return result;
}

@end
@implementation JavaUtilEnumMap_EnumMapKeySet_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (JavaLangEnum *)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return ((JavaUtilMapEntry *) NIL_CHK(entry)).key;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

@end
@implementation JavaUtilEnumMap_EnumMapValueCollection

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (JavaUtilEnumMap *)enumMap {
  return enumMap_;
}
@synthesize enumMap = enumMap_;

- (id)initWithJavaUtilEnumMap:(JavaUtilEnumMap *)em {
  if ((self = [super init])) {
    enumMap_ = em;
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)clear {
  [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) clear];
}

- (BOOL)containsWithId:(id)object {
  return [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) containsValueWithId:object];
}

- (id<JavaUtilIterator>)iterator {
  return [[[JavaUtilEnumMap_EnumMapIterator alloc] initWithJavaUtilMapEntry_Type:[[[JavaUtilEnumMap_EnumMapValueCollection_$1 alloc] init] autorelease] withJavaUtilEnumMap:enumMap_] autorelease];
}

- (BOOL)removeWithId:(id)object {
  if (nil == object) {
    for (int i = 0; i < ((JavaUtilEnumMap *) NIL_CHK(enumMap_)).enumSize; i++) {
      if ([((IOSBooleanArray *) NIL_CHK(enumMap_.hasMapping)) booleanAtIndex:i] && nil == [((IOSObjectArray *) NIL_CHK(enumMap_.values_)) objectAtIndex:i]) {
        [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) removeWithId:((JavaLangEnum *) [((IOSObjectArray *) NIL_CHK(enumMap_.keys)) objectAtIndex:i])];
        return YES;
      }
    }
  }
  else {
    for (int i = 0; i < ((JavaUtilEnumMap *) NIL_CHK(enumMap_)).enumSize; i++) {
      if ([((IOSBooleanArray *) NIL_CHK(enumMap_.hasMapping)) booleanAtIndex:i] && [object isEqual:[((IOSObjectArray *) NIL_CHK(enumMap_.values_)) objectAtIndex:i]]) {
        [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) removeWithId:((JavaLangEnum *) [((IOSObjectArray *) NIL_CHK(enumMap_.keys)) objectAtIndex:i])];
        return YES;
      }
    }
  }
  return NO;
}

- (int)size {
  return [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) size];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilEnumMap_EnumMapValueCollection *typedCopy = (JavaUtilEnumMap_EnumMapValueCollection *) copy;
  typedCopy.enumMap = enumMap_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  return result;
}

@end
@implementation JavaUtilEnumMap_EnumMapValueCollection_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return ((JavaUtilMapEntry *) NIL_CHK(entry)).value;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

@end
@implementation JavaUtilEnumMap_EnumMapIterator

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

@synthesize position = position_;
@synthesize prePosition = prePosition_;
- (JavaUtilEnumMap *)enumMap {
  return enumMap_;
}
- (void)setEnumMap:(JavaUtilEnumMap *)enumMap {
  JreOperatorRetainedAssign(&enumMap_, enumMap);
}
@synthesize enumMap = enumMap_;
- (id<JavaUtilMapEntry_Type>)type {
  return type_;
}
- (void)setType:(id<JavaUtilMapEntry_Type>)type {
  JreOperatorRetainedAssign(&type_, type);
}
@synthesize type = type_;

- (id)initWithJavaUtilMapEntry_Type:(id<JavaUtilMapEntry_Type>)value
                withJavaUtilEnumMap:(JavaUtilEnumMap *)em {
  if ((self = [super init])) {
    position_ = 0;
    prePosition_ = -1;
    JreOperatorRetainedAssign(&enumMap_, em);
    JreOperatorRetainedAssign(&type_, value);
    JreMemDebugAdd(self);
  }
  return self;
}

- (BOOL)hasNext {
  int length = ((JavaUtilEnumMap *) NIL_CHK(enumMap_)).enumSize;
  for (; position_ < length; position_++) {
    if ([((IOSBooleanArray *) NIL_CHK(enumMap_.hasMapping)) booleanAtIndex:position_]) {
      break;
    }
  }
  return position_ != length;
}

- (id)next {
  if (![self hasNext]) {
    @throw [[[JavaUtilNoSuchElementException alloc] init] autorelease];
  }
  prePosition_ = position_++;
  return [((id<JavaUtilMapEntry_Type>) NIL_CHK(type_)) getWithJavaUtilMapEntry:[[[JavaUtilMapEntry alloc] initWithId:((JavaLangEnum *) [((IOSObjectArray *) NIL_CHK(enumMap_.keys)) objectAtIndex:prePosition_]) withId:[((IOSObjectArray *) NIL_CHK(enumMap_.values_)) objectAtIndex:prePosition_]] autorelease]];
}

- (void)remove {
  [self checkStatus];
  if ([((IOSBooleanArray *) NIL_CHK(enumMap_.hasMapping)) booleanAtIndex:prePosition_]) {
    [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) removeWithId:((JavaLangEnum *) [((IOSObjectArray *) NIL_CHK(enumMap_.keys)) objectAtIndex:prePosition_])];
  }
  prePosition_ = -1;
}

- (NSString *)description {
  if (-1 == prePosition_) {
    return (NSString *) [super description];
  }
  return [[((id<JavaUtilMapEntry_Type>) NIL_CHK(type_)) getWithJavaUtilMapEntry:[[[JavaUtilMapEntry alloc] initWithId:((JavaLangEnum *) [((IOSObjectArray *) NIL_CHK(enumMap_.keys)) objectAtIndex:prePosition_]) withId:[((IOSObjectArray *) NIL_CHK(enumMap_.values_)) objectAtIndex:prePosition_]] autorelease]] description];
}

- (void)checkStatus {
  if (-1 == prePosition_) {
    @throw [[[JavaLangIllegalStateException alloc] init] autorelease];
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&type_, nil);
  JreOperatorRetainedAssign(&enumMap_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilEnumMap_EnumMapIterator *typedCopy = (JavaUtilEnumMap_EnumMapIterator *) copy;
  typedCopy.position = position_;
  typedCopy.prePosition = prePosition_;
  typedCopy.enumMap = enumMap_;
  typedCopy.type = type_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:enumMap_ name:@"enumMap"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:type_ name:@"type"]];
  return result;
}

@end
@implementation JavaUtilEnumMap_EnumMapEntryIterator

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaUtilMapEntry_Type:(id<JavaUtilMapEntry_Type>)value
                withJavaUtilEnumMap:(JavaUtilEnumMap *)em {
  return JreMemDebugAdd([super initWithJavaUtilMapEntry_Type:value withJavaUtilEnumMap:em]);
}

- (id)next {
  if (![self hasNext]) {
    @throw [[[JavaUtilNoSuchElementException alloc] init] autorelease];
  }
  prePosition_ = position_++;
  return [((id<JavaUtilMapEntry_Type>) NIL_CHK(type_)) getWithJavaUtilMapEntry:[[[JavaUtilEnumMap_Entry alloc] initWithId:(JavaLangEnum *) ((JavaLangEnum *) [((IOSObjectArray *) NIL_CHK(enumMap_.keys)) objectAtIndex:prePosition_]) withId:(id) [((IOSObjectArray *) NIL_CHK(enumMap_.values_)) objectAtIndex:prePosition_] withJavaUtilEnumMap:enumMap_] autorelease]];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

@end
@implementation JavaUtilEnumMap_EnumMapEntrySet

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (JavaUtilEnumMap *)enumMap {
  return enumMap_;
}
@synthesize enumMap = enumMap_;

- (id)initWithJavaUtilEnumMap:(JavaUtilEnumMap *)em {
  if ((self = [super init])) {
    enumMap_ = em;
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)clear {
  [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) clear];
}

- (BOOL)containsWithId:(id)object {
  BOOL isEqual = NO;
  if ([object conformsToProtocol: @protocol(JavaUtilMap_Entry)]) {
    id enumKey = [((id<JavaUtilMap_Entry>) object) getKey];
    id enumValue = [((id<JavaUtilMap_Entry>) object) getValue];
    if ([((JavaUtilEnumMap *) NIL_CHK(enumMap_)) containsKeyWithId:enumKey]) {
      id value = [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) getWithId:enumKey];
      isEqual = (value == nil ? nil == enumValue : [NIL_CHK(value) isEqual:enumValue]);
    }
  }
  return isEqual;
}

- (id<JavaUtilIterator>)iterator {
  return [[[JavaUtilEnumMap_EnumMapEntryIterator alloc] initWithJavaUtilMapEntry_Type:[[[JavaUtilEnumMap_EnumMapEntrySet_$1 alloc] init] autorelease] withJavaUtilEnumMap:enumMap_] autorelease];
}

- (BOOL)removeWithId:(id)object {
  if ([self containsWithId:object]) {
    [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) removeWithId:[((id<JavaUtilMap_Entry>) object) getKey]];
    return YES;
  }
  return NO;
}

- (int)size {
  return [((JavaUtilEnumMap *) NIL_CHK(enumMap_)) size];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilEnumMap_EnumMapEntrySet *typedCopy = (JavaUtilEnumMap_EnumMapEntrySet *) copy;
  typedCopy.enumMap = enumMap_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  return result;
}

@end
@implementation JavaUtilEnumMap_EnumMapEntrySet_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id<JavaUtilMap_Entry>)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return entry;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

@end
