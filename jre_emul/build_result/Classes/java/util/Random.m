//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/util/Random.java
//
//  Created by retechretech on 13-4-26.
//

#import "IOSByteArray.h"
#import "java/lang/IllegalArgumentException.h"
#import "java/lang/System.h"
#import "java/util/Random.h"
#import <math.h>

@implementation JavaUtilRandom

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

@synthesize haveNextNextGaussian = haveNextNextGaussian_;
@synthesize seed = seed_;
@synthesize nextNextGaussian = nextNextGaussian_;

- (id)init {
  if ((self = [super init])) {
    [self setSeedWithLongInt:[JavaLangSystem currentTimeMillis] + [self hash]];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithLongInt:(long long int)seed {
  if ((self = [super init])) {
    [self setSeedWithLongInt:seed];
    JreMemDebugAdd(self);
  }
  return self;
}

- (int)nextWithInt:(int)bits {
  @synchronized(self) {
    {
      seed_ = (seed_ * JavaUtilRandom_multiplier + (long long) 0xbLL) & ((1LL << 48) - 1);
      return (int) ((long long) (((unsigned long long) seed_) >> (48 - bits)));
    }
  }
}

- (BOOL)nextBoolean {
  return [self nextWithInt:1] != 0;
}

- (void)nextBytesWithJavaLangByteArray:(IOSByteArray *)buf {
  int rand = 0, count = 0, loop = 0;
  while (count < (int) [((IOSByteArray *) NIL_CHK(buf)) count]) {
    if (loop == 0) {
      rand = [self nextInt];
      loop = 3;
    }
    else {
      loop--;
    }
    [((IOSByteArray *) NIL_CHK(buf)) replaceByteAtIndex:count++ withByte:(char) rand];
    rand >>= 8;
  }
}

- (double)nextDouble {
  return ((((long long int) [self nextWithInt:26] << 27) + [self nextWithInt:27]) / (double) (1LL << 53));
}

- (float)nextFloat {
  return ([self nextWithInt:24] / 16777216.0f);
}

- (double)nextGaussian {
  @synchronized(self) {
    {
      if (haveNextNextGaussian_) {
        haveNextNextGaussian_ = NO;
        return nextNextGaussian_;
      }
      double v1, v2, s;
      do {
        v1 = 2 * [self nextDouble] - 1;
        v2 = 2 * [self nextDouble] - 1;
        s = v1 * v1 + v2 * v2;
      }
      while (s >= 1);
      double norm = [JavaUtilRandom iOS_sqrtWithDouble:-2 * [JavaUtilRandom iOS_logWithDouble:s] / s];
      nextNextGaussian_ = v2 * norm;
      haveNextNextGaussian_ = YES;
      return v1 * norm;
    }
  }
}

+ (double)iOS_sqrtWithDouble:(double)a   {
    // Use math.h function.
    return sqrt(a);
  }

+ (double)iOS_logWithDouble:(double)a   {
    // Use math.h function.
    return log(a);
  }

- (int)nextInt {
  return [self nextWithInt:32];
}

- (int)nextIntWithInt:(int)n {
  if (n > 0) {
    if ((n & -n) == n) {
      return (int) ((n * (long long int) [self nextWithInt:31]) >> 31);
    }
    int bits, val;
    do {
      bits = [self nextWithInt:31];
      val = bits % n;
    }
    while (bits - val + (n - 1) < 0);
    return val;
  }
  @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
}

- (long long int)nextLong {
  return ((long long int) [self nextWithInt:32] << 32) + [self nextWithInt:32];
}

- (void)setSeedWithLongInt:(long long int)seed {
  @synchronized(self) {
    {
      self.seed = (seed ^ JavaUtilRandom_multiplier) & ((1LL << 48) - 1);
      haveNextNextGaussian_ = NO;
    }
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaUtilRandom *typedCopy = (JavaUtilRandom *) copy;
  typedCopy.haveNextNextGaussian = haveNextNextGaussian_;
  typedCopy.seed = seed_;
  typedCopy.nextNextGaussian = nextNextGaussian_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  return result;
}

@end
