//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/lang/Float.java
//
//  Created by retechretech on 13-4-19.
//

#import "IOSClass.h"
#import "IOSFloatArray.h"
#import "java/lang/ClassCastException.h"
#import "java/lang/Float.h"
#import "java/lang/NullPointerException.h"
// From apache-harmony/classlib/modules/luni/src/main/native/luni/shared/floatbits.c
#define SINGLE_EXPONENT_MASK    0x7F800000
#define SINGLE_MANTISSA_MASK    0x007FFFFF
#define SINGLE_NAN_BITS         (SINGLE_EXPONENT_MASK | 0x00400000)

@implementation JavaLangFloat

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaLangFloat_TYPE_ name:@"JavaLangFloat_TYPE_"]];
  return result;
}

static IOSClass * JavaLangFloat_TYPE_;

@synthesize value = value_;

+ (float)MAX_VALUE {
  return JavaLangFloat_MAX_VALUE;
}

+ (float)MIN_VALUE {
  return JavaLangFloat_MIN_VALUE;
}

+ (float)NaN {
  return JavaLangFloat_NaN;
}

+ (float)POSITIVE_INFINITY {
  return JavaLangFloat_POSITIVE_INFINITY;
}

+ (float)NEGATIVE_INFINITY {
  return JavaLangFloat_NEGATIVE_INFINITY;
}

+ (IOSClass *)TYPE {
  return JavaLangFloat_TYPE_;
}

+ (int)SIZE {
  return JavaLangFloat_SIZE;
}

- (id)initJavaLangFloatWithFloat:(float)value {
  if ((self = [super init])) {
    self.value = value;
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithFloat:(float)value {
  return [self initJavaLangFloatWithFloat:value];
}

- (id)initWithDouble:(double)value {
  if ((self = [super init])) {
    self.value = (float) value;
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSString:(NSString *)string {
  return JreMemDebugAdd([self initJavaLangFloatWithFloat:[JavaLangFloat parseFloatWithNSString:string]]);
}

- (int)compareToWithId:(JavaLangFloat *)object {
  if (object != nil && ![object isKindOfClass:[JavaLangFloat class]]) {
    @throw [[[JavaLangClassCastException alloc] init] autorelease];
  }
  if (object == nil) {
    @throw [[[JavaLangNullPointerException alloc] init] autorelease];
  }
  return [JavaLangFloat compareWithFloat:value_ withFloat:((JavaLangFloat *) NIL_CHK(object)).value];
}

- (char)byteValue {
  return (char) value_;
}

- (double)doubleValue {
  return value_;
}

- (BOOL)isEqual:(id)object {
  if (!object) return NO;
  NSComparisonResult result = [self compare:object];
  return result == NSOrderedSame;
}

+ (int)floatToIntBitsWithFloat:(float)value   {
    // Modified from Harmony JNI implementation.
    int intValue = *(int *) &value;
    if ((intValue & SINGLE_EXPONENT_MASK) == SINGLE_EXPONENT_MASK) {
      if (intValue & SINGLE_MANTISSA_MASK) {
        return SINGLE_NAN_BITS;
      }
    }
    return intValue;
  }

+ (int)floatToRawIntBitsWithFloat:(float)value   {
    return *(int *) &value;
  }

- (float)floatValue {
  return value_;
}

- (NSUInteger)hash {
  return [JavaLangFloat floatToIntBitsWithFloat:value_];
}

+ (float)intBitsToFloatWithInt:(int)bits   {
    return *(float *) &bits;
  }

- (int)intValue {
  return (int) value_;
}

- (BOOL)isInfinite {
  return [JavaLangFloat isInfiniteWithFloat:value_];
}

+ (BOOL)isInfiniteWithFloat:(float)f   {
    return isinf(f);
  }

- (BOOL)isNaN {
  return [JavaLangFloat isNaNWithFloat:value_];
}

+ (BOOL)isNaNWithFloat:(float)f   {
    return isnan(f);
  }

- (long long int)longLongValue {
  return (long long int) value_;
}

+ (float)parseFloatWithNSString:(NSString *)string   {
    return [string floatValue];
  }

- (short int)shortValue {
  return (short int) value_;
}

- (NSString *)description {
  return [JavaLangFloat toStringWithFloat:value_];
}

+ (NSString *)toStringWithFloat:(float)f   {
    return [NSString stringWithFormat:@"%01.1f", f];
  }

+ (JavaLangFloat *)valueOfWithNSString:(NSString *)string {
  return [JavaLangFloat valueOfWithFloat:[JavaLangFloat parseFloatWithNSString:string]];
}

+ (int)compareWithFloat:(float)float1
              withFloat:(float)float2 {
  if (float1 > float2) {
    return 1;
  }
  if (float2 > float1) {
    return -1;
  }
  if (float1 == float2 && 0.0f != float1) {
    return 0;
  }
  if ([JavaLangFloat isNaNWithFloat:float1]) {
    if ([JavaLangFloat isNaNWithFloat:float2]) {
      return 0;
    }
    return 1;
  }
  else if ([JavaLangFloat isNaNWithFloat:float2]) {
    return -1;
  }
  int f1 = [JavaLangFloat floatToRawIntBitsWithFloat:float1];
  int f2 = [JavaLangFloat floatToRawIntBitsWithFloat:float2];
  return (f1 >> 31) - (f2 >> 31);
}

+ (JavaLangFloat *)valueOfWithFloat:(float)f {
  return [[[JavaLangFloat alloc] initWithFloat:f] autorelease];
}

+ (NSString *)toHexStringWithFloat:(float)f   {
    return [NSString stringWithFormat:@"%A", (double) f];
  }

+ (void)initialize {
  if (self == [JavaLangFloat class]) {
    JreOperatorRetainedAssign(&JavaLangFloat_TYPE_, (IOSClass *) [[[[[IOSFloatArray alloc] initWithLength:0] autorelease] getClass] getComponentType]);
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

- (void)getValue:(void *)buffer {
  *((float *) buffer) = value_;
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaLangFloat *typedCopy = (JavaLangFloat *) copy;
  typedCopy.value = value_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  return result;
}

- (const char *)objCType {
  return "f";
}

@end
