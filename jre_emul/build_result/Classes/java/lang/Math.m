//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: Classes/java/lang/Math.java
//
//  Created by retechretech on 13-4-19.
//

#import "java/lang/Double.h"
#import "java/lang/Float.h"
#import "java/lang/Math.h"
#import "java/lang/StrictMath.h"
#import "java/util/Random.h"

@implementation JavaLangMath

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaLangMath_random__ name:@"JavaLangMath_random__"]];
  return result;
}

static JavaUtilRandom * JavaLangMath_random__;

+ (double)E {
  return JavaLangMath_E;
}

+ (double)PI {
  return JavaLangMath_PI;
}

+ (JavaUtilRandom *)random_ {
  return JavaLangMath_random__;
}

+ (void)setRandom_:(JavaUtilRandom *)random_ {
  JreOperatorRetainedAssign(&JavaLangMath_random__, random_);
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

+ (double)absWithDouble:(double)d {
  long long int bits = [JavaLangDouble doubleToLongBitsWithDouble:d];
  bits &= (long long) 0x7fffffffffffffffLL;
  return [JavaLangDouble longBitsToDoubleWithLongInt:bits];
}

+ (float)absWithFloat:(float)f {
  int bits = [JavaLangFloat floatToIntBitsWithFloat:f];
  bits &= (int) 0x7fffffff;
  return [JavaLangFloat intBitsToFloatWithInt:bits];
}

+ (int)absWithInt:(int)i {
  return i >= 0 ? i : -i;
}

+ (long long int)absWithLongInt:(long long int)l {
  return l >= 0 ? l : -l;
}

+ (double)acosWithDouble:(double)d   {
    return acos(d);
  }

+ (double)asinWithDouble:(double)d   {
    return asin(d);
  }

+ (double)atanWithDouble:(double)d   {
    return atan(d);
  }

+ (double)atan2WithDouble:(double)x
               withDouble:(double)y   {
    return atan2(x, y);
  }

+ (double)cbrtWithDouble:(double)d   {
    return cbrt(d);
  }

+ (double)ceilWithDouble:(double)d   {
    return ceil(d);
  }

+ (double)cosWithDouble:(double)d   {
    return cos(d);
  }

+ (double)coshWithDouble:(double)d   {
    return cosh(d);
  }

+ (double)expWithDouble:(double)d   {
    return exp(d);
  }

+ (double)expm1WithDouble:(double)d   {
    return expm1(d);
  }

+ (double)floorWithDouble:(double)d   {
    return floor(d);
  }

+ (double)hypotWithDouble:(double)x
               withDouble:(double)y   {
    return hypot(x, y);
  }

+ (double)IEEEremainderWithDouble:(double)x
                       withDouble:(double)y   {
    // According to the Mac OS X math.h online man page, their routines are
    // all IEEE Standard 754 compliant.
    return remainder(x, y);
  }

+ (double)logWithDouble:(double)d   {
    return log(d);
  }

+ (double)log10WithDouble:(double)d   {
    return log10(d);
  }

+ (double)log1pWithDouble:(double)d   {
    return log1p(d);
  }

+ (double)maxWithDouble:(double)d1
             withDouble:(double)d2   {
    return fmax(d1, d2);
  }

+ (float)maxWithFloat:(float)f1
            withFloat:(float)f2   {
    return fmaxf(f1, f2);
  }

+ (int)maxWithInt:(int)i1
          withInt:(int)i2 {
  return i1 > i2 ? i1 : i2;
}

+ (long long int)maxWithLongInt:(long long int)l1
                    withLongInt:(long long int)l2 {
  return l1 > l2 ? l1 : l2;
}

+ (double)minWithDouble:(double)d1
             withDouble:(double)d2   {
    return fmin(d1, d2);
  }

+ (float)minWithFloat:(float)f1
            withFloat:(float)f2   {
    return fminf(f1, f2);
  }

+ (int)minWithInt:(int)i1
          withInt:(int)i2 {
  return i1 < i2 ? i1 : i2;
}

+ (long long int)minWithLongInt:(long long int)l1
                    withLongInt:(long long int)l2 {
  return l1 < l2 ? l1 : l2;
}

+ (double)powWithDouble:(double)x
             withDouble:(double)y   {
    return pow(x, y);
  }

+ (double)rintWithDouble:(double)d   {
    return rint(d);
  }

+ (long long int)roundWithDouble:(double)d {
  if (d != d) {
    return 0LL;
  }
  return (long long int) [JavaLangMath floorWithDouble:d + 0.5];
}

+ (int)roundWithFloat:(float)f {
  if (f != f) {
    return 0;
  }
  return (int) [JavaLangMath floorWithDouble:f + 0.5f];
}

+ (double)signumWithDouble:(double)d {
  return [JavaLangStrictMath signumWithDouble:d];
}

+ (float)signumWithFloat:(float)f {
  return [JavaLangStrictMath signumWithFloat:f];
}

+ (double)sinWithDouble:(double)d   {
    return sin(d);
  }

+ (double)sinhWithDouble:(double)d   {
    return sinh(d);
  }

+ (double)sqrtWithDouble:(double)d   {
    return sqrt(d);
  }

+ (double)tanWithDouble:(double)d   {
    return tan(d);
  }

+ (double)tanhWithDouble:(double)d   {
    return tanh(d);
  }

+ (double)random {
  if (JavaLangMath_random__ == nil) {
    JreOperatorRetainedAssign(&JavaLangMath_random__, [[[JavaUtilRandom alloc] init] autorelease]);
  }
  return [((JavaUtilRandom *) NIL_CHK(JavaLangMath_random__)) nextDouble];
}

+ (double)toRadiansWithDouble:(double)angdeg {
  return angdeg / 180.0 * JavaLangMath_PI;
}

+ (double)toDegreesWithDouble:(double)angrad {
  return angrad * 180.0 / JavaLangMath_PI;
}

+ (double)ulpWithDouble:(double)d {
  if ([JavaLangDouble isInfiniteWithDouble:d]) {
    return JavaLangDouble_POSITIVE_INFINITY;
  }
  else if (d == JavaLangDouble_MAX_VALUE || d == -JavaLangDouble_MAX_VALUE) {
    return [JavaLangMath powWithDouble:2 withDouble:971];
  }
  d = [JavaLangMath absWithDouble:d];
  return [JavaLangMath nextafterWithDouble:d withDouble:JavaLangDouble_MAX_VALUE] - d;
}

+ (float)ulpWithFloat:(float)f {
  if ([JavaLangFloat isNaNWithFloat:f]) {
    return JavaLangFloat_NaN;
  }
  else if ([JavaLangFloat isInfiniteWithFloat:f]) {
    return JavaLangFloat_POSITIVE_INFINITY;
  }
  else if (f == JavaLangFloat_MAX_VALUE || f == -JavaLangFloat_MAX_VALUE) {
    return (float) [JavaLangMath powWithDouble:2 withDouble:104];
  }
  f = [JavaLangMath absWithFloat:f];
  return [JavaLangMath nextafterfWithFloat:f withFloat:JavaLangFloat_MAX_VALUE] - f;
}

+ (double)nextafterWithDouble:(double)x
                   withDouble:(double)y   {
    return nextafter(x, y);
  }

+ (float)nextafterfWithFloat:(float)x
                   withFloat:(float)y   {
    return nextafterf(x, y);
  }

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

@end
