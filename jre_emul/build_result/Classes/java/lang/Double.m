//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/lang/Double.java
//
//  Created by retechretech on 13-4-14.
//

#import "IOSClass.h"
#import "IOSDoubleArray.h"
#import "java/lang/ClassCastException.h"
#import "java/lang/Double.h"
#import "java/lang/NullPointerException.h"
// From apache-harmony/classlib/modules/luni/src/main/native/luni/shared/floatbits.c,
// apache-harmony/classlib/modules/portlib/src/main/native/include/shared/hycomp.h
#define HYCONST64(x)            x##LL
#define DOUBLE_EXPONENT_MASK    HYCONST64(0x7FF0000000000000)
#define DOUBLE_MANTISSA_MASK    HYCONST64(0x000FFFFFFFFFFFFF)
#define DOUBLE_NAN_BITS         (DOUBLE_EXPONENT_MASK | HYCONST64(0x0008000000000000))

@implementation JavaLangDouble

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaLangDouble_TYPE_ name:@"JavaLangDouble_TYPE_"]];
  return result;
}

static IOSClass * JavaLangDouble_TYPE_;

@synthesize value = value_;

+ (double)MAX_VALUE {
  return JavaLangDouble_MAX_VALUE;
}

+ (double)MIN_VALUE {
  return JavaLangDouble_MIN_VALUE;
}

+ (double)NaN {
  return JavaLangDouble_NaN;
}

+ (double)POSITIVE_INFINITY {
  return JavaLangDouble_POSITIVE_INFINITY;
}

+ (double)NEGATIVE_INFINITY {
  return JavaLangDouble_NEGATIVE_INFINITY;
}

+ (IOSClass *)TYPE {
  return JavaLangDouble_TYPE_;
}

+ (int)SIZE {
  return JavaLangDouble_SIZE;
}

- (id)initJavaLangDoubleWithDouble:(double)value {
  if ((self = [super init])) {
    self.value = value;
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithDouble:(double)value {
  return [self initJavaLangDoubleWithDouble:value];
}

- (id)initWithNSString:(NSString *)string {
  return JreMemDebugAdd([self initJavaLangDoubleWithDouble:[JavaLangDouble parseDoubleWithNSString:string]]);
}

- (int)compareToWithId:(JavaLangDouble *)object {
  if (object != nil && ![object isKindOfClass:[JavaLangDouble class]]) {
    @throw [[[JavaLangClassCastException alloc] init] autorelease];
  }
  if (object == nil) {
    @throw [[[JavaLangNullPointerException alloc] init] autorelease];
  }
  return [JavaLangDouble compareWithDouble:value_ withDouble:((JavaLangDouble *) NIL_CHK(object)).value];
}

- (char)byteValue {
  return (char) value_;
}

+ (long long int)doubleToLongBitsWithDouble:(double)value   {
    // Modified from Harmony JNI implementation.
    long long longValue = *(long long *) &value;
    if ((longValue & DOUBLE_EXPONENT_MASK) == DOUBLE_EXPONENT_MASK) {
      if (longValue & DOUBLE_MANTISSA_MASK) {
        return DOUBLE_NAN_BITS;
      }
    }
    return longValue;
  }

+ (long long int)doubleToRawLongBitsWithDouble:(double)value   {
    return *(long long *) &value;
  }

- (double)doubleValue {
  return value_;
}

- (BOOL)isEqual:(id)object {
  if (!object) return NO;
  NSComparisonResult result = [self compare:object];
  return result == NSOrderedSame;
}

- (float)floatValue {
  return (float) value_;
}

- (NSUInteger)hash {
  long long int v = [JavaLangDouble doubleToLongBitsWithDouble:value_];
  return (int) (v ^ ((long long) (((unsigned long long) v) >> 32)));
}

- (int)intValue {
  return (int) value_;
}

- (BOOL)isInfinite {
  return [JavaLangDouble isInfiniteWithDouble:value_];
}

+ (BOOL)isInfiniteWithDouble:(double)d   {
    return isinf(d);
  }

- (BOOL)isNaN {
  return [JavaLangDouble isNaNWithDouble:value_];
}

+ (BOOL)isNaNWithDouble:(double)d   {
    return isnan(d);
  }

+ (double)longBitsToDoubleWithLongInt:(long long int)bits   {
    return *(double *) &bits;
  }

- (long long int)longLongValue {
  return (long long int) value_;
}

+ (double)parseDoubleWithNSString:(NSString *)string   {
    return [string doubleValue];
  }

- (short int)shortValue {
  return (short int) value_;
}

- (NSString *)description {
  return [JavaLangDouble toStringWithDouble:value_];
}

+ (NSString *)toStringWithDouble:(double)d   {
    return [NSString stringWithFormat:@"%01.1f", d];
  }

+ (JavaLangDouble *)valueOfWithNSString:(NSString *)string {
  return [[[JavaLangDouble alloc] initWithDouble:[JavaLangDouble parseDoubleWithNSString:string]] autorelease];
}

+ (int)compareWithDouble:(double)double1
              withDouble:(double)double2 {
  if (double1 > double2) {
    return 1;
  }
  if (double2 > double1) {
    return -1;
  }
  if (double1 == double2 && 0.0 != double1) {
    return 0;
  }
  if ([JavaLangDouble isNaNWithDouble:double1]) {
    if ([JavaLangDouble isNaNWithDouble:double2]) {
      return 0;
    }
    return 1;
  }
  else if ([JavaLangDouble isNaNWithDouble:double2]) {
    return -1;
  }
  long long int d1 = [JavaLangDouble doubleToRawLongBitsWithDouble:double1];
  long long int d2 = [JavaLangDouble doubleToRawLongBitsWithDouble:double2];
  return (int) ((d1 >> 63) - (d2 >> 63));
}

+ (JavaLangDouble *)valueOfWithDouble:(double)d {
  return [[[JavaLangDouble alloc] initWithDouble:d] autorelease];
}

+ (NSString *)toHexStringWithDouble:(double)d   {
    return [NSString stringWithFormat:@"%A", d];
  }

+ (void)initialize {
  if (self == [JavaLangDouble class]) {
    JreOperatorRetainedAssign(&JavaLangDouble_TYPE_, (IOSClass *) [[[[[IOSDoubleArray alloc] initWithLength:0] autorelease] getClass] getComponentType]);
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

- (void)getValue:(void *)buffer {
  *((double *) buffer) = value_;
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaLangDouble *typedCopy = (JavaLangDouble *) copy;
  typedCopy.value = value_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  return result;
}

- (const char *)objCType {
  return "d";
}

@end
