//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/nio/src/main/java/common/java/nio/HeapByteBuffer.java
//
//  Created by retechretech on 13-4-19.
//

#import "IOSByteArray.h"
#import "java/lang/Double.h"
#import "java/lang/Float.h"
#import "java/lang/IndexOutOfBoundsException.h"
#import "java/lang/System.h"
#import "java/nio/Buffer.h"
#import "java/nio/BufferUnderflowException.h"
#import "java/nio/ByteBuffer.h"
#import "java/nio/HeapByteBuffer.h"
#import "org/apache/harmony/luni/platform/Endianness.h"

@implementation JavaNioHeapByteBuffer

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (IOSByteArray *)backingArray {
  return backingArray_;
}
- (void)setBackingArray:(IOSByteArray *)backingArray {
  JreOperatorRetainedAssign(&backingArray_, backingArray);
}
@synthesize backingArray = backingArray_;
@synthesize offset = offset_;

- (id)initWithJavaLangByteArray:(IOSByteArray *)backingArray {
  return JreMemDebugAdd([self initJavaNioHeapByteBufferWithJavaLangByteArray:backingArray withInt:(int) [((IOSByteArray *) NIL_CHK(backingArray)) count] withInt:0]);
}

- (id)initWithInt:(int)capacity {
  return JreMemDebugAdd([self initJavaNioHeapByteBufferWithJavaLangByteArray:[[[IOSByteArray alloc] initWithLength:capacity] autorelease] withInt:capacity withInt:0]);
}

- (id)initJavaNioHeapByteBufferWithJavaLangByteArray:(IOSByteArray *)backingArray
                                             withInt:(int)capacity
                                             withInt:(int)offset {
  if ((self = [super initWithInt:capacity])) {
    self.backingArray = backingArray;
    self.offset = offset;
    if (offset + capacity > (int) [((IOSByteArray *) NIL_CHK(backingArray)) count]) {
      @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaLangByteArray:(IOSByteArray *)backingArray
                        withInt:(int)capacity
                        withInt:(int)offset {
  return [self initJavaNioHeapByteBufferWithJavaLangByteArray:backingArray withInt:capacity withInt:offset];
}

- (JavaNioByteBuffer *)getWithJavaLangByteArray:(IOSByteArray *)dest
                                        withInt:(int)off
                                        withInt:(int)len {
  int length = (int) [((IOSByteArray *) NIL_CHK(dest)) count];
  if (off < 0 || len < 0 || (long long int) off + (long long int) len > length) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
  }
  if (len > [self remaining]) {
    @throw [[[JavaNioBufferUnderflowException alloc] init] autorelease];
  }
  [JavaLangSystem arraycopyWithId:backingArray_ withInt:offset_ + position__ withId:dest withInt:off withInt:len];
  position__ += len;
  return self;
}

- (char)get {
  if (position__ == limit__) {
    @throw [[[JavaNioBufferUnderflowException alloc] init] autorelease];
  }
  return [((IOSByteArray *) NIL_CHK(backingArray_)) byteAtIndex:offset_ + position__++];
}

- (char)getWithInt:(int)index {
  if (index < 0 || index >= limit__) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
  }
  return [((IOSByteArray *) NIL_CHK(backingArray_)) byteAtIndex:offset_ + index];
}

- (double)getDouble {
  return [JavaLangDouble longBitsToDoubleWithLongInt:[self getLong]];
}

- (double)getDoubleWithInt:(int)index {
  return [JavaLangDouble longBitsToDoubleWithLongInt:[self getLongWithInt:index]];
}

- (float)getFloat {
  return [JavaLangFloat intBitsToFloatWithInt:[self getInt]];
}

- (float)getFloatWithInt:(int)index {
  return [JavaLangFloat intBitsToFloatWithInt:[self getIntWithInt:index]];
}

- (int)getInt {
  int newPosition = position__ + 4;
  if (newPosition > limit__) {
    @throw [[[JavaNioBufferUnderflowException alloc] init] autorelease];
  }
  int result = [self loadIntWithInt:position__];
  position__ = newPosition;
  return result;
}

- (int)getIntWithInt:(int)index {
  if (index < 0 || index + 4 > limit__) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
  }
  return [self loadIntWithInt:index];
}

- (long long int)getLong {
  int newPosition = position__ + 8;
  if (newPosition > limit__) {
    @throw [[[JavaNioBufferUnderflowException alloc] init] autorelease];
  }
  long long int result = [self loadLongWithInt:position__];
  position__ = newPosition;
  return result;
}

- (long long int)getLongWithInt:(int)index {
  if (index < 0 || index + 8 > limit__) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
  }
  return [self loadLongWithInt:index];
}

- (short int)getShort {
  int newPosition = position__ + 2;
  if (newPosition > limit__) {
    @throw [[[JavaNioBufferUnderflowException alloc] init] autorelease];
  }
  short int result = [self loadShortWithInt:position__];
  position__ = newPosition;
  return result;
}

- (short int)getShortWithInt:(int)index {
  if (index < 0 || index + 2 > limit__) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
  }
  return [self loadShortWithInt:index];
}

- (BOOL)isDirect {
  return NO;
}

- (int)loadIntWithInt:(int)index {
  int baseOffset = offset_ + index;
  int bytes = 0;
  if (order__ == [OrgApacheHarmonyLuniPlatformEndianness getBIG_ENDIAN]) {
    for (int i = 0; i < 4; i++) {
      bytes = bytes << 8;
      bytes = bytes | ([((IOSByteArray *) NIL_CHK(backingArray_)) byteAtIndex:baseOffset + i] & (int) 0xFF);
    }
  }
  else {
    for (int i = 3; i >= 0; i--) {
      bytes = bytes << 8;
      bytes = bytes | ([((IOSByteArray *) NIL_CHK(backingArray_)) byteAtIndex:baseOffset + i] & (int) 0xFF);
    }
  }
  return bytes;
}

- (long long int)loadLongWithInt:(int)index {
  int baseOffset = offset_ + index;
  long long int bytes = 0;
  if (order__ == [OrgApacheHarmonyLuniPlatformEndianness getBIG_ENDIAN]) {
    for (int i = 0; i < 8; i++) {
      bytes = bytes << 8;
      bytes = bytes | ([((IOSByteArray *) NIL_CHK(backingArray_)) byteAtIndex:baseOffset + i] & (int) 0xFF);
    }
  }
  else {
    for (int i = 7; i >= 0; i--) {
      bytes = bytes << 8;
      bytes = bytes | ([((IOSByteArray *) NIL_CHK(backingArray_)) byteAtIndex:baseOffset + i] & (int) 0xFF);
    }
  }
  return bytes;
}

- (short int)loadShortWithInt:(int)index {
  int baseOffset = offset_ + index;
  short int bytes = 0;
  if (order__ == [OrgApacheHarmonyLuniPlatformEndianness getBIG_ENDIAN]) {
    bytes = (short int) ([((IOSByteArray *) NIL_CHK(backingArray_)) byteAtIndex:baseOffset] << 8);
    bytes |= ([((IOSByteArray *) NIL_CHK(backingArray_)) byteAtIndex:baseOffset + 1] & (int) 0xFF);
  }
  else {
    bytes = (short int) ([((IOSByteArray *) NIL_CHK(backingArray_)) byteAtIndex:baseOffset + 1] << 8);
    bytes |= ([((IOSByteArray *) NIL_CHK(backingArray_)) byteAtIndex:baseOffset] & (int) 0xFF);
  }
  return bytes;
}

- (void)storeWithInt:(int)index
             withInt:(int)value {
  int baseOffset = offset_ + index;
  if (order__ == [OrgApacheHarmonyLuniPlatformEndianness getBIG_ENDIAN]) {
    for (int i = 3; i >= 0; i--) {
      [((IOSByteArray *) NIL_CHK(backingArray_)) replaceByteAtIndex:baseOffset + i withByte:(char) (value & (int) 0xFF)];
      value = value >> 8;
    }
  }
  else {
    for (int i = 0; i <= 3; i++) {
      [((IOSByteArray *) NIL_CHK(backingArray_)) replaceByteAtIndex:baseOffset + i withByte:(char) (value & (int) 0xFF)];
      value = value >> 8;
    }
  }
}

- (void)storeWithInt:(int)index
         withLongInt:(long long int)value {
  int baseOffset = offset_ + index;
  if (order__ == [OrgApacheHarmonyLuniPlatformEndianness getBIG_ENDIAN]) {
    for (int i = 7; i >= 0; i--) {
      [((IOSByteArray *) NIL_CHK(backingArray_)) replaceByteAtIndex:baseOffset + i withByte:(char) (value & (int) 0xFF)];
      value = value >> 8;
    }
  }
  else {
    for (int i = 0; i <= 7; i++) {
      [((IOSByteArray *) NIL_CHK(backingArray_)) replaceByteAtIndex:baseOffset + i withByte:(char) (value & (int) 0xFF)];
      value = value >> 8;
    }
  }
}

- (void)storeWithInt:(int)index
        withShortInt:(short int)value {
  int baseOffset = offset_ + index;
  if (order__ == [OrgApacheHarmonyLuniPlatformEndianness getBIG_ENDIAN]) {
    [((IOSByteArray *) NIL_CHK(backingArray_)) replaceByteAtIndex:baseOffset withByte:(char) ((value >> 8) & (int) 0xFF)];
    [((IOSByteArray *) NIL_CHK(backingArray_)) replaceByteAtIndex:baseOffset + 1 withByte:(char) (value & (int) 0xFF)];
  }
  else {
    [((IOSByteArray *) NIL_CHK(backingArray_)) replaceByteAtIndex:baseOffset + 1 withByte:(char) ((value >> 8) & (int) 0xFF)];
    [((IOSByteArray *) NIL_CHK(backingArray_)) replaceByteAtIndex:baseOffset withByte:(char) (value & (int) 0xFF)];
  }
}

- (unichar)getChar {
  return (unichar) [self getShort];
}

- (unichar)getCharWithInt:(int)index {
  return (unichar) [self getShortWithInt:index];
}

- (JavaNioByteBuffer *)putCharWithUnichar:(unichar)value {
  return [self putShortWithShortInt:(short int) value];
}

- (JavaNioByteBuffer *)putCharWithInt:(int)index
                          withUnichar:(unichar)value {
  return [self putShortWithInt:index withShortInt:(short int) value];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&backingArray_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaNioHeapByteBuffer *typedCopy = (JavaNioHeapByteBuffer *) copy;
  typedCopy.backingArray = backingArray_;
  typedCopy.offset = offset_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:backingArray_ name:@"backingArray"]];
  return result;
}

@end
