//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/io/File.java
//
//  Created by retechretech on 13-4-19.
//

#import "IOSByteArray.h"
#import "IOSCharArray.h"
#import "IOSClass.h"
#import "IOSObjectArray.h"
#import "java/io/File.h"
#import "java/io/FileFilter.h"
#import "java/io/FilenameFilter.h"
#import "java/io/IOException.h"
#import "java/lang/AssertionError.h"
#import "java/lang/ClassCastException.h"
#import "java/lang/IllegalArgumentException.h"
#import "java/lang/InternalError.h"
#import "java/lang/NullPointerException.h"
#import "java/lang/StringBuilder.h"
#import "java/lang/System.h"
#import "java/util/ArrayList.h"
#import "java/util/List.h"
#import "java/util/Locale.h"
#import "java/util/Random.h"
#import <sys/utsname.h>

@implementation JavaIoFile

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaIoFile_EMPTY_STRING_ name:@"JavaIoFile_EMPTY_STRING_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaIoFile_separator_ name:@"JavaIoFile_separator_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaIoFile_pathSeparator_ name:@"JavaIoFile_pathSeparator_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaIoFile_tempFileLocker_ name:@"JavaIoFile_tempFileLocker_"]];
  return result;
}

static NSString * JavaIoFile_EMPTY_STRING_ = @"";
static NSString * JavaIoFile_separator_ = @"/";
static NSString * JavaIoFile_pathSeparator_ = @":";
static int JavaIoFile_counter_;
static int JavaIoFile_counterBase_;
static JavaIoFile_TempFileLocker * JavaIoFile_tempFileLocker_;
static BOOL JavaIoFile_caseSensitive_;

- (NSString *)path {
  return path_;
}
- (void)setPath:(NSString *)path {
  JreOperatorRetainedAssign(&path_, path);
}
@synthesize path = path_;
- (NSString *)properPath_ {
  return properPath__;
}
- (void)setProperPath_:(NSString *)properPath_ {
  JreOperatorRetainedAssign(&properPath__, properPath_);
}
@synthesize properPath_ = properPath__;

+ (NSString *)EMPTY_STRING {
  return JavaIoFile_EMPTY_STRING_;
}

+ (unichar)separatorChar {
  return JavaIoFile_separatorChar;
}

+ (NSString *)separator {
  return JavaIoFile_separator_;
}

+ (unichar)pathSeparatorChar {
  return JavaIoFile_pathSeparatorChar;
}

+ (NSString *)pathSeparator {
  return JavaIoFile_pathSeparator_;
}

+ (int)counter {
  return JavaIoFile_counter_;
}

+ (int *)counterRef {
  return &JavaIoFile_counter_;
}

+ (int)counterBase {
  return JavaIoFile_counterBase_;
}

+ (int *)counterBaseRef {
  return &JavaIoFile_counterBase_;
}

+ (JavaIoFile_TempFileLocker *)tempFileLocker {
  return JavaIoFile_tempFileLocker_;
}

+ (void)setTempFileLocker:(JavaIoFile_TempFileLocker *)tempFileLocker {
  JreOperatorRetainedAssign(&JavaIoFile_tempFileLocker_, tempFileLocker);
}

+ (BOOL)caseSensitive {
  return JavaIoFile_caseSensitive_;
}

+ (BOOL *)caseSensitiveRef {
  return &JavaIoFile_caseSensitive_;
}

- (id)initWithJavaIoFile:(JavaIoFile *)dir
            withNSString:(NSString *)name {
  if ((self = [super init])) {
    if (name == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    if (dir == nil) {
      self.path = [self fixSlashesWithNSString:name];
    }
    else {
      self.path = [self calculatePathWithNSString:[dir getPath] withNSString:name];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSString:(NSString *)path {
  if ((self = [super init])) {
    self.path = [self fixSlashesWithNSString:path];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSString:(NSString *)dirPath
          withNSString:(NSString *)name {
  if ((self = [super init])) {
    if (name == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    if (dirPath == nil) {
      self.path = [self fixSlashesWithNSString:name];
    }
    else {
      self.path = [self calculatePathWithNSString:dirPath withNSString:name];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (NSString *)calculatePathWithNSString:(NSString *)dirPath
                           withNSString:(NSString *)name {
  dirPath = [self fixSlashesWithNSString:dirPath];
  if (![NIL_CHK(name) isEqual:JavaIoFile_EMPTY_STRING_] || [NIL_CHK(dirPath) isEqual:JavaIoFile_EMPTY_STRING_]) {
    name = [self fixSlashesWithNSString:name];
    int separatorIndex = 0;
    while ((separatorIndex < [NIL_CHK(name) length]) && ([NIL_CHK(name) charAtWithInt:separatorIndex] == JavaIoFile_separatorChar)) {
      separatorIndex++;
    }
    if (separatorIndex > 0) {
      name = [NIL_CHK(name) substring:separatorIndex endIndex:[NIL_CHK(name) length]];
    }
    if ([NIL_CHK(dirPath) length] > 0 && ([NIL_CHK(dirPath) charAtWithInt:[NIL_CHK(dirPath) length] - 1] == JavaIoFile_separatorChar)) {
      return [NSString stringWithFormat:@"%@%@", dirPath, name];
    }
    return [NSString stringWithFormat:@"%@/%@", dirPath, name];
  }
  return dirPath;
}

+ (BOOL)isCaseSensitiveImpl   {
    // True for iOS, not OS X/simulator.
    struct utsname systemInfo;
    uname(&systemInfo);
    if (strcmp(systemInfo.machine, "i386") == 0 || strncmp(systemInfo.machine, "x86", 3) == 0) {
      return false;
    }
    return true;
  }

+ (IOSObjectArray *)listRoots {
  return [IOSObjectArray arrayWithObjects:(id[]){ [[[JavaIoFile alloc] initWithNSString:@"/"] autorelease] } count:1 type:[IOSClass classWithClass:[JavaIoFile class]]];
}

- (NSString *)fixSlashesWithNSString:(NSString *)origPath {
  int uncIndex = 1;
  int length = [NIL_CHK(origPath) length], newLength = 0;
  uncIndex = 0;
  BOOL foundSlash = NO;
  IOSCharArray *newPath = [NIL_CHK(origPath) toCharArray];
  for (int i = 0; i < length; i++) {
    unichar pathChar = [((IOSCharArray *) NIL_CHK(newPath)) charAtIndex:i];
    if (pathChar == '/') {
      if ((foundSlash && i == uncIndex) || !foundSlash) {
        [((IOSCharArray *) NIL_CHK(newPath)) replaceCharAtIndex:newLength++ withChar:JavaIoFile_separatorChar];
        foundSlash = YES;
      }
    }
    else {
      if (pathChar == ':' && uncIndex > 0 && (newLength == 2 || (newLength == 3 && [((IOSCharArray *) NIL_CHK(newPath)) charAtIndex:1] == JavaIoFile_separatorChar)) && [((IOSCharArray *) NIL_CHK(newPath)) charAtIndex:0] == JavaIoFile_separatorChar) {
        [((IOSCharArray *) NIL_CHK(newPath)) replaceCharAtIndex:0 withChar:[((IOSCharArray *) NIL_CHK(newPath)) charAtIndex:newLength - 1]];
        newLength = 1;
        uncIndex = 2;
      }
      [((IOSCharArray *) NIL_CHK(newPath)) replaceCharAtIndex:newLength++ withChar:pathChar];
      foundSlash = NO;
    }
  }
  if (foundSlash && (newLength > (uncIndex + 1) || (newLength == 2 && [((IOSCharArray *) NIL_CHK(newPath)) charAtIndex:0] != JavaIoFile_separatorChar))) {
    newLength--;
  }
  return [NSString stringWithCharacters:newPath offset:0 length:newLength];
}

- (BOOL)canRead {
  if ([NIL_CHK(path_) length] == 0) {
    return NO;
  }
  NSString *pp = [self properPathWithBOOL:YES];
  return [self existsImplWithNSString:pp] && [self isReadableImplWithNSString:pp];
}

- (BOOL)canWrite {
  BOOL exists = NO;
  if ([NIL_CHK(path_) length] > 0) {
    exists = [self existsImplWithNSString:[self properPathWithBOOL:YES]];
  }
  return exists && [self isWritableImplWithNSString:[self properPathWithBOOL:YES]];
}

- (int)compareToWithId:(JavaIoFile *)another {
  if (another != nil && ![another isKindOfClass:[JavaIoFile class]]) {
    @throw [[[JavaLangClassCastException alloc] init] autorelease];
  }
  if (JavaIoFile_caseSensitive_) {
    return [[self getPath] compareToWithId:[((JavaIoFile *) NIL_CHK(another)) getPath]];
  }
  return [[self getPath] compareToIgnoreCase:[((JavaIoFile *) NIL_CHK(another)) getPath]];
}

- (BOOL)delete__ {
  NSString *propPath = [self properPathWithBOOL:YES];
  if (([NIL_CHK(propPath) length] != 0) && [self isDirectoryImplWithNSString:propPath]) {
    return [self deleteDirImplWithNSString:propPath];
  }
  return [self deleteFileImplWithNSString:propPath];
}

- (BOOL)deleteDirImplWithNSString:(NSString *)filePath   {
    NSArray *files =
    [[NSFileManager defaultManager] contentsOfDirectoryAtPath:filePath error:nil];
    if (!files || [files count] > 0) {  // Don't delete if non-empty.
    return false;
  }
  return [self deleteFileImplWithNSString:filePath];
}

- (BOOL)deleteFileImplWithNSString:(NSString *)filePath   {
    NSFileManager *manager = [NSFileManager defaultManager];
    if (![manager fileExistsAtPath:filePath isDirectory:NULL]) {
      return NO;
    }
    if (![manager isDeletableFileAtPath:filePath]) {
      return NO;
    }
    return [[NSFileManager defaultManager] removeItemAtPath:filePath error:nil];
  }

- (void)deleteOnExit {
  @throw [[[JavaLangAssertionError alloc] initWithId:@"not implemented"] autorelease];
}

- (BOOL)isEqual:(id)obj {
  if (!([obj isKindOfClass:[JavaIoFile class]])) {
    return NO;
  }
  if (!JavaIoFile_caseSensitive_) {
    return [NIL_CHK(path_) equalsIgnoreCase:[((JavaIoFile *) obj) getPath]];
  }
  return [NIL_CHK(path_) isEqual:[((JavaIoFile *) obj) getPath]];
}

- (BOOL)exists {
  if ([NIL_CHK(path_) length] == 0) {
    return NO;
  }
  return [self existsImplWithNSString:[self properPathWithBOOL:YES]];
}

- (BOOL)existsImplWithNSString:(NSString *)filePath   {
    return [[NSFileManager defaultManager] fileExistsAtPath:filePath];
  }

- (NSString *)getAbsolutePath {
  return [self properPathWithBOOL:NO];
}

- (JavaIoFile *)getAbsoluteFile {
  return [[[JavaIoFile alloc] initWithNSString:[self getAbsolutePath]] autorelease];
}

- (NSString *)getCanonicalPath {
  return [self getAbsolutePath];
}

- (IOSByteArray *)resolveWithJavaLangByteArray:(IOSByteArray *)newResult {
  int last = 1, nextSize, linkSize;
  IOSByteArray *linkPath = newResult, *bytes;
  BOOL done, inPlace;
  for (int i = 1; i <= (int) [((IOSByteArray *) NIL_CHK(newResult)) count]; i++) {
    if (i == (int) [((IOSByteArray *) NIL_CHK(newResult)) count] || [((IOSByteArray *) NIL_CHK(newResult)) byteAtIndex:i] == JavaIoFile_separatorChar) {
      done = i >= (int) [((IOSByteArray *) NIL_CHK(newResult)) count] - 1;
      if (done && (int) [((IOSByteArray *) NIL_CHK(linkPath)) count] == 1) {
        return newResult;
      }
      inPlace = NO;
      if (linkPath == newResult) {
        bytes = newResult;
        if (!done) {
          inPlace = YES;
          [((IOSByteArray *) NIL_CHK(newResult)) replaceByteAtIndex:i withByte:0x0000];
        }
      }
      else {
        nextSize = i - last + 1;
        linkSize = (int) [((IOSByteArray *) NIL_CHK(linkPath)) count];
        if ([((IOSByteArray *) NIL_CHK(linkPath)) byteAtIndex:linkSize - 1] == JavaIoFile_separatorChar) {
          linkSize--;
        }
        bytes = [[[IOSByteArray alloc] initWithLength:linkSize + nextSize] autorelease];
        [JavaLangSystem arraycopyWithId:linkPath withInt:0 withId:bytes withInt:0 withInt:linkSize];
        [JavaLangSystem arraycopyWithId:newResult withInt:last - 1 withId:bytes withInt:linkSize withInt:nextSize];
      }
      if (done) {
        return bytes;
      }
      linkPath = [self resolveLinkWithJavaLangByteArray:bytes withInt:inPlace ? i : (int) [((IOSByteArray *) NIL_CHK(bytes)) count] withBOOL:YES];
      if (inPlace) {
        [((IOSByteArray *) NIL_CHK(newResult)) replaceByteAtIndex:i withByte:'/'];
      }
      last = i + 1;
    }
  }
  @throw [[[JavaLangInternalError alloc] init] autorelease];
}

- (IOSByteArray *)resolveLinkWithJavaLangByteArray:(IOSByteArray *)pathBytes
                                           withInt:(int)length
                                          withBOOL:(BOOL)resolveAbsolute {
  BOOL restart = NO;
  IOSByteArray *linkBytes, *temp;
  do {
    linkBytes = [[self getLinkImplWithNSString:[NSString stringWithBytes:pathBytes]] getBytes];
    if (linkBytes == pathBytes) {
      break;
    }
    if ([((IOSByteArray *) NIL_CHK(linkBytes)) byteAtIndex:0] == JavaIoFile_separatorChar) {
      restart = resolveAbsolute;
      pathBytes = linkBytes;
    }
    else {
      int last = length - 1;
      while ([((IOSByteArray *) NIL_CHK(pathBytes)) byteAtIndex:last] != JavaIoFile_separatorChar) {
        last--;
      }
      last++;
      temp = [[[IOSByteArray alloc] initWithLength:last + (int) [((IOSByteArray *) NIL_CHK(linkBytes)) count]] autorelease];
      [JavaLangSystem arraycopyWithId:pathBytes withInt:0 withId:temp withInt:0 withInt:last];
      [JavaLangSystem arraycopyWithId:linkBytes withInt:0 withId:temp withInt:last withInt:(int) [((IOSByteArray *) NIL_CHK(linkBytes)) count]];
      pathBytes = temp;
    }
    length = (int) [((IOSByteArray *) NIL_CHK(pathBytes)) count];
  }
  while ([self existsImplWithNSString:[NSString stringWithBytes:pathBytes]]);
  if (restart) {
    return [self resolveWithJavaLangByteArray:pathBytes];
  }
  return pathBytes;
}

- (JavaIoFile *)getCanonicalFile {
  return [[[JavaIoFile alloc] initWithNSString:[self getCanonicalPath]] autorelease];
}

- (NSString *)getName {
  int separatorIndex = [NIL_CHK(path_) lastIndexOfString:JavaIoFile_separator_];
  return (separatorIndex < 0) ? path_ : [NIL_CHK(path_) substring:separatorIndex + 1 endIndex:[NIL_CHK(path_) length]];
}

- (NSString *)getParent {
  int length = [NIL_CHK(path_) length], firstInPath = 0;
  int index = [NIL_CHK(path_) lastIndexOf:JavaIoFile_separatorChar];
  if (index == -1 && firstInPath > 0) {
    index = 2;
  }
  if (index == -1 || [NIL_CHK(path_) charAtWithInt:length - 1] == JavaIoFile_separatorChar) {
    return nil;
  }
  if ([NIL_CHK(path_) indexOf:JavaIoFile_separatorChar] == index && [NIL_CHK(path_) charAtWithInt:firstInPath] == JavaIoFile_separatorChar) {
    return [NIL_CHK(path_) substring:0 endIndex:index + 1];
  }
  return [NIL_CHK(path_) substring:0 endIndex:index];
}

- (JavaIoFile *)getParentFile {
  NSString *tempParent = [self getParent];
  if (tempParent == nil) {
    return nil;
  }
  return [[[JavaIoFile alloc] initWithNSString:tempParent] autorelease];
}

- (NSString *)getPath {
  return path_;
}

- (NSUInteger)hash {
  if (JavaIoFile_caseSensitive_) {
    return [NIL_CHK(path_) hash] ^ 1234321;
  }
  return [[NIL_CHK(path_) lowercaseStringWithJRELocale:[JavaUtilLocale ENGLISH]] hash] ^ 1234321;
}

- (BOOL)isAbsolute {
  return ([NIL_CHK(path_) length] > 0 && [NIL_CHK(path_) charAtWithInt:0] == JavaIoFile_separatorChar);
}

- (BOOL)isDirectory {
  if ([NIL_CHK(path_) length] == 0) {
    return NO;
  }
  return [self isDirectoryImplWithNSString:[self properPathWithBOOL:YES]];
}

- (BOOL)isDirectoryImplWithNSString:(NSString *)filePath   {
    BOOL isDir;
    BOOL exists = [[NSFileManager defaultManager] fileExistsAtPath:filePath isDirectory:&isDir];
    return exists && isDir;
  }

- (BOOL)isFile {
  if ([NIL_CHK(path_) length] == 0) {
    return NO;
  }
  return [self isFileImplWithNSString:[self properPathWithBOOL:YES]];
}

- (BOOL)isFileImplWithNSString:(NSString *)filePath   {
    BOOL isDir;
    BOOL exists = [[NSFileManager defaultManager] fileExistsAtPath:filePath isDirectory:&isDir];
    return exists && !isDir;
  }

- (BOOL)isHidden {
  if ([NIL_CHK(path_) length] == 0) {
    return NO;
  }
  return [self isHiddenImplWithNSString:[self properPathWithBOOL:YES]];
}

- (BOOL)isHiddenImplWithNSString:(NSString *)filePath {
  return [[self getName] hasPrefix:@"."];
}

- (BOOL)isReadableImplWithNSString:(NSString *)filePath   {
    return [[NSFileManager defaultManager] isReadableFileAtPath:filePath];
  }

- (BOOL)isWritableImplWithNSString:(NSString *)filePath   {
    return [[NSFileManager defaultManager] isWritableFileAtPath:filePath];
  }

- (NSString *)getLinkImplWithNSString:(NSString *)filePath   {
    return [[NSFileManager defaultManager] destinationOfSymbolicLinkAtPath:filePath error:nil];
  }

- (long long int)lastModified {
  long long int result = [self lastModifiedImplWithNSString:[self properPathWithBOOL:YES]];
  if (result == -1 || result == 0) {
    return 0;
  }
  return result;
}

- (long long int)lastModifiedImplWithNSString:(NSString *)filePath   {
    NSDictionary *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath
    error:nil];
    NSDate *lastModified = [attributes fileModificationDate];
    NSTimeInterval seconds = [lastModified timeIntervalSince1970];
    return llround(seconds * 1000);
  }

- (BOOL)setLastModifiedWithLongInt:(long long int)time {
  if (time < 0) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"time must be positive"] autorelease];
  }
  return ([self setLastModifiedImplWithNSString:[self properPathWithBOOL:YES] withLongInt:time]);
}

- (BOOL)setAttributeWithNSString:(NSString *)path
                    withNSString:(NSString *)attributeKey
                          withId:(id)value   {
    NSMutableDictionary *attributes = [NSMutableDictionary dictionaryWithCapacity:1];
    [attributes setObject:value forKey:attributeKey];
    return [[NSFileManager defaultManager] setAttributes:attributes ofItemAtPath:path error:nil];
  }

- (BOOL)setLastModifiedImplWithNSString:(NSString *)path
                            withLongInt:(long long int)time   {
    NSTimeInterval seconds = time / 1000.0;
    NSDate *lastModified = [NSDate dateWithTimeIntervalSince1970:seconds];
    return [self setAttributeWithNSString:path
    withNSString:NSFileModificationDate
    withId:lastModified];
  }

- (BOOL)setReadOnly {
  return ([self setReadOnlyImplWithNSString:[self properPathWithBOOL:YES]]);
}

- (BOOL)setReadOnlyImplWithNSString:(NSString *)path   {
    return [self setAttributeWithNSString:path
    withNSString:NSFileImmutable
    withId:[NSNumber numberWithBool:YES]];
  }

- (long long int)length {
  return [self lengthImplWithNSString:[self properPathWithBOOL:YES]];
}

- (long long int)lengthImplWithNSString:(NSString *)filePath   {
    return [[[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil] fileSize];
  }

- (IOSObjectArray *)list {
  if ([NIL_CHK(path_) length] == 0) {
    return nil;
  }
  NSString *bs = [self properPathWithBOOL:YES];
  if (![self isDirectoryImplWithNSString:bs] || ![self existsImplWithNSString:bs] || ![self isReadableImplWithNSString:bs]) {
    return nil;
  }
  IOSObjectArray *implList = [JavaIoFile listImplWithNSString:bs];
  if (implList == nil) {
    return [[[IOSObjectArray alloc] initWithLength:0 type:[IOSClass classWithClass:[NSString class]]] autorelease];
  }
  return implList;
}

- (IOSObjectArray *)listFiles {
  IOSObjectArray *tempNames = [self list];
  if (tempNames == nil) {
    return nil;
  }
  int resultLength = (int) [((IOSObjectArray *) NIL_CHK(tempNames)) count];
  IOSObjectArray *results = [[[IOSObjectArray alloc] initWithLength:resultLength type:[IOSClass classWithClass:[JavaIoFile class]]] autorelease];
  for (int i = 0; i < resultLength; i++) {
    [((IOSObjectArray *) NIL_CHK(results)) replaceObjectAtIndex:i withObject:[[[JavaIoFile alloc] initWithJavaIoFile:self withNSString:((NSString *) [((IOSObjectArray *) NIL_CHK(tempNames)) objectAtIndex:i])] autorelease]];
  }
  return results;
}

- (IOSObjectArray *)listFilesWithJavaIoFilenameFilter:(id<JavaIoFilenameFilter>)filter {
  IOSObjectArray *tempNames = [self listWithJavaIoFilenameFilter:filter];
  if (tempNames == nil) {
    return nil;
  }
  int resultLength = (int) [((IOSObjectArray *) NIL_CHK(tempNames)) count];
  IOSObjectArray *results = [[[IOSObjectArray alloc] initWithLength:resultLength type:[IOSClass classWithClass:[JavaIoFile class]]] autorelease];
  for (int i = 0; i < resultLength; i++) {
    [((IOSObjectArray *) NIL_CHK(results)) replaceObjectAtIndex:i withObject:[[[JavaIoFile alloc] initWithJavaIoFile:self withNSString:((NSString *) [((IOSObjectArray *) NIL_CHK(tempNames)) objectAtIndex:i])] autorelease]];
  }
  return results;
}

- (IOSObjectArray *)listFilesWithJavaIoFileFilter:(id<JavaIoFileFilter>)filter {
  if ([NIL_CHK(path_) length] == 0) {
    return nil;
  }
  NSString *bs = [self properPathWithBOOL:YES];
  if (![self isDirectoryImplWithNSString:bs] || ![self existsImplWithNSString:bs] || ![self isReadableImplWithNSString:bs]) {
    return nil;
  }
  IOSObjectArray *implList = [JavaIoFile listImplWithNSString:bs];
  if (implList == nil) {
    return [[[IOSObjectArray alloc] initWithLength:0 type:[IOSClass classWithClass:[JavaIoFile class]]] autorelease];
  }
  id<JavaUtilList> tempResult = [[[JavaUtilArrayList alloc] init] autorelease];
  for (int index = 0; index < (int) [((IOSObjectArray *) NIL_CHK(implList)) count]; index++) {
    NSString *aName = [NSString stringWithString:((NSString *) [((IOSObjectArray *) NIL_CHK(implList)) objectAtIndex:index])];
    JavaIoFile *aFile = [[[JavaIoFile alloc] initWithJavaIoFile:self withNSString:aName] autorelease];
    if (filter == nil || [((id<JavaIoFileFilter>) NIL_CHK(filter)) acceptWithJavaIoFile:aFile]) {
      [((id<JavaUtilList>) NIL_CHK(tempResult)) addWithId:aFile];
    }
  }
  return [((id<JavaUtilList>) NIL_CHK(tempResult)) toArrayWithNSObjectArray:[[[IOSObjectArray alloc] initWithLength:[((id<JavaUtilList>) NIL_CHK(tempResult)) size] type:[IOSClass classWithClass:[JavaIoFile class]]] autorelease]];
}

- (IOSObjectArray *)listWithJavaIoFilenameFilter:(id<JavaIoFilenameFilter>)filter {
  if ([NIL_CHK(path_) length] == 0) {
    return nil;
  }
  NSString *bs = [self properPathWithBOOL:YES];
  if (![self isDirectoryImplWithNSString:bs] || ![self existsImplWithNSString:bs] || ![self isReadableImplWithNSString:bs]) {
    return nil;
  }
  IOSObjectArray *implList = [JavaIoFile listImplWithNSString:bs];
  if (implList == nil) {
    return [[[IOSObjectArray alloc] initWithLength:0 type:[IOSClass classWithClass:[NSString class]]] autorelease];
  }
  id<JavaUtilList> tempResult = [[[JavaUtilArrayList alloc] init] autorelease];
  for (int index = 0; index < (int) [((IOSObjectArray *) NIL_CHK(implList)) count]; index++) {
    NSString *aName = [NSString stringWithString:((NSString *) [((IOSObjectArray *) NIL_CHK(implList)) objectAtIndex:index])];
    if (filter == nil || [((id<JavaIoFilenameFilter>) NIL_CHK(filter)) acceptWithJavaIoFile:self withNSString:aName]) {
      [((id<JavaUtilList>) NIL_CHK(tempResult)) addWithId:aName];
    }
  }
  return [((id<JavaUtilList>) NIL_CHK(tempResult)) toArrayWithNSObjectArray:[[[IOSObjectArray alloc] initWithLength:[((id<JavaUtilList>) NIL_CHK(tempResult)) size] type:[IOSClass classWithClass:[NSString class]]] autorelease]];
}

+ (IOSObjectArray *)listImplWithNSString:(NSString *)path   {
    NSArray *fileArray =
    [[NSFileManager defaultManager] contentsOfDirectoryAtPath:path error:nil];
    IOSObjectArray *files =
    [[IOSObjectArray alloc] initWithLength:[fileArray count]
    type:[IOSClass classWithClass:[NSString class]]];
    #if ! __has_feature(objc_arc)
    [files autorelease];
    #endif
    NSUInteger nFiles = [fileArray count];
    for (NSUInteger i = 0; i < nFiles; i++) {
      [files replaceObjectAtIndex:i withObject:[fileArray objectAtIndex:i]];
    }
    return files;
  }

- (BOOL)mkdir {
  return [self mkdirImplWithNSString:[self properPathWithBOOL:YES]];
}

- (BOOL)mkdirImplWithNSString:(NSString *)filePath   {
    return [[NSFileManager defaultManager] createDirectoryAtPath:filePath
    withIntermediateDirectories:NO
    attributes:nil
    error:nil];
  }

- (BOOL)mkdirs {
  if ([self exists]) {
    return NO;
  }
  if ([self mkdir]) {
    return YES;
  }
  NSString *parentDir = [self getParent];
  if (parentDir == nil) {
    return NO;
  }
  return ([((JavaIoFile *) [[[JavaIoFile alloc] initWithNSString:parentDir] autorelease]) mkdirs] && [self mkdir]);
}

- (BOOL)createNewFile {
  if (0 == [NIL_CHK(path_) length]) {
    @throw [[[JavaIoIOException alloc] initWithNSString:@"No such file or directory"] autorelease];
  }
  int result = [self newFileImplWithNSString:[self properPathWithBOOL:YES]];
  switch (result) {
    case 0:
    return YES;
    case 1:
    return NO;
    default:
    @throw [[[JavaIoIOException alloc] initWithNSString:[NSString stringWithFormat:@"Cannot create: %@", path_]] autorelease];
  }
}

- (int)newFileImplWithNSString:(NSString *)filePath OBJC_METHOD_FAMILY_NONE   {
    if ([self existsImplWithNSString:filePath]) {
      return 1;
    }
    if ([[NSFileManager defaultManager] createFileAtPath:filePath
    contents:[NSData data]
    attributes:nil]) {
      return 0;
    }
    NSException *e = [[JavaIoIOException alloc] init];
    #if ! __has_feature(objc_arc)
    [e autorelease];
    #endif
    @throw e;
  }

+ (JavaIoFile *)createTempFileWithNSString:(NSString *)prefix
                              withNSString:(NSString *)suffix {
  return [JavaIoFile createTempFileWithNSString:prefix withNSString:suffix withJavaIoFile:nil];
}

+ (JavaIoFile *)createTempFileWithNSString:(NSString *)prefix
                              withNSString:(NSString *)suffix
                            withJavaIoFile:(JavaIoFile *)directory {
  if ([NIL_CHK(prefix) length] < 3) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Prefix must be at least 3 characters"] autorelease];
  }
  NSString *newSuffix = suffix == nil ? @".tmp" : suffix;
  JavaIoFile *tmpDirFile;
  if (directory == nil) {
    NSString *tmpDir = [JavaLangSystem getPropertyWithNSString:@"java.io.tmpdir" withNSString:@"."];
    tmpDirFile = [[[JavaIoFile alloc] initWithNSString:tmpDir] autorelease];
  }
  else {
    tmpDirFile = directory;
  }
  JavaIoFile *result;
  do {
    result = [JavaIoFile genTempFileWithNSString:prefix withNSString:newSuffix withJavaIoFile:tmpDirFile];
  }
  while (![((JavaIoFile *) NIL_CHK(result)) createNewFile]);
  return result;
}

+ (JavaIoFile *)genTempFileWithNSString:(NSString *)prefix
                           withNSString:(NSString *)suffix
                         withJavaIoFile:(JavaIoFile *)directory {
  int identify = 0;
  @synchronized (JavaIoFile_tempFileLocker_) {
    if (JavaIoFile_counter_ == 0) {
      int newInt = [((JavaUtilRandom *) [[[JavaUtilRandom alloc] init] autorelease]) nextInt];
      JavaIoFile_counter_ = ((newInt / 65535) & (int) 0xFFFF) + (int) 0x2710;
      JavaIoFile_counterBase_ = JavaIoFile_counter_;
    }
    identify = JavaIoFile_counter_++;
  }
  JavaLangStringBuilder *newName = [[[JavaLangStringBuilder alloc] init] autorelease];
  [((JavaLangStringBuilder *) NIL_CHK(newName)) appendWithNSString:prefix];
  [((JavaLangStringBuilder *) NIL_CHK(newName)) appendWithInt:JavaIoFile_counterBase_];
  [((JavaLangStringBuilder *) NIL_CHK(newName)) appendWithInt:identify];
  [((JavaLangStringBuilder *) NIL_CHK(newName)) appendWithNSString:suffix];
  return [[[JavaIoFile alloc] initWithJavaIoFile:directory withNSString:[((JavaLangStringBuilder *) NIL_CHK(newName)) description]] autorelease];
}

- (NSString *)properPathWithBOOL:(BOOL)internal {
  if (properPath__ != nil) {
    return properPath__;
  }
  if ([self isAbsolute]) {
    return path_;
  }
  NSString *userdir;
  userdir = [JavaLangSystem getPropertyWithNSString:@"user.dir"];
  if ([NIL_CHK(path_) length] == 0) {
    return JreOperatorRetainedAssign(&properPath__, userdir);
  }
  int length = [NIL_CHK(userdir) length];
  NSString *result = userdir;
  if ([NIL_CHK(userdir) charAtWithInt:length - 1] != JavaIoFile_separatorChar) {
    if ([NIL_CHK(path_) charAtWithInt:0] != JavaIoFile_separatorChar) {
      result = [NSString stringWithFormat:@"%@/", result];
    }
  }
  else if ([NIL_CHK(path_) charAtWithInt:0] == JavaIoFile_separatorChar) {
    result = [NIL_CHK(result) substring:0 endIndex:length - 2];
  }
  result = [NSString stringWithFormat:@"%@%@", result, path_];
  return JreOperatorRetainedAssign(&properPath__, result);
}

- (BOOL)renameToWithJavaIoFile:(JavaIoFile *)dest {
  return [self renameToImplWithNSString:[self properPathWithBOOL:YES] withNSString:[((JavaIoFile *) NIL_CHK(dest)) properPathWithBOOL:YES]];
}

- (BOOL)renameToImplWithNSString:(NSString *)pathExist
                    withNSString:(NSString *)pathNew   {
    return [[NSFileManager defaultManager] moveItemAtPath:pathExist toPath:pathNew error:nil];
  }

- (NSString *)description {
  return path_;
}

- (NSString *)getAbsoluteName {
  JavaIoFile *f = [self getAbsoluteFile];
  NSString *name = [((JavaIoFile *) NIL_CHK(f)) getPath];
  if ([((JavaIoFile *) NIL_CHK(f)) isDirectory] && [NIL_CHK(name) charAtWithInt:[NIL_CHK(name) length] - 1] != JavaIoFile_separatorChar) {
    name = [[[((JavaLangStringBuilder *) [[[JavaLangStringBuilder alloc] initWithInt:[NIL_CHK(name) length] + 1] autorelease]) appendWithNSString:name] appendWithUnichar:'/'] description];
  }
  return name;
}

+ (void)initialize {
  if (self == [JavaIoFile class]) {
    JavaIoFile_counter_ = 0;
    JavaIoFile_counterBase_ = 0;
    JreOperatorRetainedAssign(&JavaIoFile_tempFileLocker_, [[[JavaIoFile_TempFileLocker alloc] init] autorelease]);
    {
      JavaIoFile_caseSensitive_ = [JavaIoFile isCaseSensitiveImpl];
    }
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&properPath__, nil);
  JreOperatorRetainedAssign(&path_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaIoFile *typedCopy = (JavaIoFile *) copy;
  typedCopy.path = path_;
  typedCopy.properPath_ = properPath__;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:path_ name:@"path"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:properPath__ name:@"properPath_"]];
  return result;
}

@end
@implementation JavaIoFile_TempFileLocker

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

@end
