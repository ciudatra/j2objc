//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/retechretech/dev/tools/lib/j2objc/jre_emul/apache_harmony/classlib/modules/luni/src/main/java/java/io/BufferedWriter.java
//
//  Created by retechretech on 13-3-15.
//

#import "IOSCharArray.h"
#import "java/io/BufferedWriter.h"
#import "java/io/IOException.h"
#import "java/io/Writer.h"
#import "java/lang/IllegalArgumentException.h"
#import "java/lang/IndexOutOfBoundsException.h"
#import "java/lang/NullPointerException.h"
#import "java/lang/StringIndexOutOfBoundsException.h"
#import "java/lang/System.h"

@implementation JavaIoBufferedWriter

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (JavaIoWriter *)out {
  return [[out_ retain] autorelease];
}
- (void)setOut:(JavaIoWriter *)out {
  JreOperatorRetainedAssign(&out_, out);
}
@synthesize out = out_;
- (IOSCharArray *)buf {
  return [[buf_ retain] autorelease];
}
- (void)setBuf:(IOSCharArray *)buf {
  JreOperatorRetainedAssign(&buf_, buf);
}
@synthesize buf = buf_;
@synthesize pos = pos_;
- (NSString *)lineSeparator {
  return [[lineSeparator_ retain] autorelease];
}
- (void)setLineSeparator:(NSString *)lineSeparator {
  JreOperatorRetainedAssign(&lineSeparator_, lineSeparator);
}
@synthesize lineSeparator = lineSeparator_;

- (id)initWithJavaIoWriter:(JavaIoWriter *)outArg {
  if ((self = [super initWithId:outArg])) {
    JreOperatorRetainedAssign(&lineSeparator_, @"\n");
    self.out = outArg;
    JreOperatorRetainedAssign(&buf_, [[[IOSCharArray alloc] initWithLength:8192] autorelease]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaIoWriter:(JavaIoWriter *)outArg
                   withInt:(int)size {
  if ((self = [super initWithId:outArg])) {
    JreOperatorRetainedAssign(&lineSeparator_, @"\n");
    if (size <= 0) {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"size must be > 0"] autorelease];
    }
    self.out = outArg;
    self.buf = [[[IOSCharArray alloc] initWithLength:size] autorelease];
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)close {
  @synchronized (lock_) {
    if ([self isClosed]) {
      return;
    }
    JavaIoIOException *thrown = nil;
    @try {
      [self flushInternal];
    }
    @catch (JavaIoIOException *e) {
      thrown = e;
    }
    JreOperatorRetainedAssign(&buf_, nil);
    @try {
      [((JavaIoWriter *) NIL_CHK(out_)) close];
    }
    @catch (JavaIoIOException *e) {
      if (thrown == nil) {
        thrown = e;
      }
    }
    JreOperatorRetainedAssign(&out_, nil);
    if (thrown != nil) {
      @throw thrown;
    }
  }
}

- (void)flush {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"writer is closed"] autorelease];
    }
    [self flushInternal];
    [((JavaIoWriter *) NIL_CHK(out_)) flush];
  }
}

- (void)flushInternal {
  if (pos_ > 0) {
    [((JavaIoWriter *) NIL_CHK(out_)) writeWithJavaLangCharacterArray:buf_ withInt:0 withInt:pos_];
  }
  pos_ = 0;
}

- (BOOL)isClosed {
  return out_ == nil;
}

- (void)newLine OBJC_METHOD_FAMILY_NONE {
  [self writeWithNSString:lineSeparator_ withInt:0 withInt:[NIL_CHK(lineSeparator_) length]];
}

- (void)writeWithJavaLangCharacterArray:(IOSCharArray *)cbuf
                                withInt:(int)offset
                                withInt:(int)count {
  if (cbuf == nil) {
    @throw [[[JavaLangNullPointerException alloc] init] autorelease];
  }
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"writer is closed"] autorelease];
    }
    if (offset < 0 || offset > (int) [((IOSCharArray *) NIL_CHK(cbuf)) count] - count || count < 0) {
      @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
    }
    if (pos_ == 0 && count >= (int) [((IOSCharArray *) NIL_CHK(self.buf)) count]) {
      [((JavaIoWriter *) NIL_CHK(out_)) writeWithJavaLangCharacterArray:cbuf withInt:offset withInt:count];
      return;
    }
    int available = (int) [((IOSCharArray *) NIL_CHK(self.buf)) count] - pos_;
    if (count < available) {
      available = count;
    }
    if (available > 0) {
      [JavaLangSystem arraycopyWithId:cbuf withInt:offset withId:self.buf withInt:pos_ withInt:available];
      pos_ += available;
    }
    if (pos_ == (int) [((IOSCharArray *) NIL_CHK(self.buf)) count]) {
      [((JavaIoWriter *) NIL_CHK(out_)) writeWithJavaLangCharacterArray:self.buf withInt:0 withInt:(int) [((IOSCharArray *) NIL_CHK(self.buf)) count]];
      pos_ = 0;
      if (count > available) {
        offset += available;
        available = count - available;
        if (available >= (int) [((IOSCharArray *) NIL_CHK(self.buf)) count]) {
          [((JavaIoWriter *) NIL_CHK(out_)) writeWithJavaLangCharacterArray:cbuf withInt:offset withInt:available];
          return;
        }
        [JavaLangSystem arraycopyWithId:cbuf withInt:offset withId:self.buf withInt:pos_ withInt:available];
        pos_ += available;
      }
    }
  }
}

- (void)writeWithInt:(int)oneChar {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"writer is closed"] autorelease];
    }
    if (pos_ >= (int) [((IOSCharArray *) NIL_CHK(buf_)) count]) {
      [((JavaIoWriter *) NIL_CHK(out_)) writeWithJavaLangCharacterArray:buf_ withInt:0 withInt:(int) [((IOSCharArray *) NIL_CHK(buf_)) count]];
      pos_ = 0;
    }
    [((IOSCharArray *) NIL_CHK(buf_)) replaceCharAtIndex:pos_++ withChar:(unichar) oneChar];
  }
}

- (void)writeWithNSString:(NSString *)str
                  withInt:(int)offset
                  withInt:(int)count {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"writer is closed"] autorelease];
    }
    if (count <= 0) {
      return;
    }
    if (str == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    if (offset > [NIL_CHK(str) length] - count || offset < 0) {
      @throw [[[JavaLangStringIndexOutOfBoundsException alloc] init] autorelease];
    }
    if (pos_ == 0 && count >= (int) [((IOSCharArray *) NIL_CHK(buf_)) count]) {
      IOSCharArray *chars = [[[IOSCharArray alloc] initWithLength:count] autorelease];
      [NIL_CHK(str) getChars:offset sourceEnd:offset + count destination:chars destinationBegin:0];
      [((JavaIoWriter *) NIL_CHK(out_)) writeWithJavaLangCharacterArray:chars withInt:0 withInt:count];
      return;
    }
    int available = (int) [((IOSCharArray *) NIL_CHK(buf_)) count] - pos_;
    if (count < available) {
      available = count;
    }
    if (available > 0) {
      [NIL_CHK(str) getChars:offset sourceEnd:offset + available destination:buf_ destinationBegin:pos_];
      pos_ += available;
    }
    if (pos_ == (int) [((IOSCharArray *) NIL_CHK(buf_)) count]) {
      [((JavaIoWriter *) NIL_CHK(out_)) writeWithJavaLangCharacterArray:self.buf withInt:0 withInt:(int) [((IOSCharArray *) NIL_CHK(self.buf)) count]];
      pos_ = 0;
      if (count > available) {
        offset += available;
        available = count - available;
        if (available >= (int) [((IOSCharArray *) NIL_CHK(buf_)) count]) {
          IOSCharArray *chars = [[[IOSCharArray alloc] initWithLength:count] autorelease];
          [NIL_CHK(str) getChars:offset sourceEnd:offset + available destination:chars destinationBegin:0];
          [((JavaIoWriter *) NIL_CHK(out_)) writeWithJavaLangCharacterArray:chars withInt:0 withInt:available];
          return;
        }
        [NIL_CHK(str) getChars:offset sourceEnd:offset + available destination:buf_ destinationBegin:pos_];
        pos_ += available;
      }
    }
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&lineSeparator_, nil);
  JreOperatorRetainedAssign(&buf_, nil);
  JreOperatorRetainedAssign(&out_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaIoBufferedWriter *typedCopy = (JavaIoBufferedWriter *) copy;
  typedCopy.out = out_;
  typedCopy.buf = buf_;
  typedCopy.pos = pos_;
  typedCopy.lineSeparator = lineSeparator_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:out_ name:@"out"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:buf_ name:@"buf"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:lineSeparator_ name:@"lineSeparator"]];
  return result;
}

@end
