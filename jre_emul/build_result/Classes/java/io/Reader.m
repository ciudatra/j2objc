//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/io/Reader.java
//
//  Created by retechretech on 13-4-19.
//

#import "IOSCharArray.h"
#import "java/io/IOException.h"
#import "java/io/Reader.h"
#import "java/lang/IllegalArgumentException.h"
#import "java/lang/Math.h"
#import "java/lang/NullPointerException.h"
#import "java/nio/CharBuffer.h"

@implementation JavaIoReader

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)lock {
  return lock_;
}
- (void)setLock:(id)lock {
  JreOperatorRetainedAssign(&lock_, lock);
}
@synthesize lock = lock_;

- (id)init {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&lock_, [[[NSObject alloc] init] autorelease]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithId:(id)lock {
  if ((self = [super init])) {
    if (lock == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    self.lock = lock;
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)close {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)markWithInt:(int)readLimit {
  @throw [[[JavaIoIOException alloc] init] autorelease];
}

- (BOOL)markSupported {
  return NO;
}

- (int)read {
  @synchronized (lock_) {
    IOSCharArray *charArray = [[[IOSCharArray alloc] initWithLength:1] autorelease];
    if ([self readWithJavaLangCharacterArray:charArray withInt:0 withInt:1] != -1) {
      return [((IOSCharArray *) NIL_CHK(charArray)) charAtIndex:0];
    }
    return -1;
  }
}

- (int)readWithJavaLangCharacterArray:(IOSCharArray *)buf {
  return [self readWithJavaLangCharacterArray:buf withInt:0 withInt:(int) [((IOSCharArray *) NIL_CHK(buf)) count]];
}

- (int)readWithJavaLangCharacterArray:(IOSCharArray *)buf
                              withInt:(int)offset
                              withInt:(int)count {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (BOOL)ready {
  return NO;
}

- (void)reset {
  @throw [[[JavaIoIOException alloc] init] autorelease];
}

- (long long int)skipWithLongInt:(long long int)count {
  if (count < 0) {
    @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
  }
  @synchronized (lock_) {
    long long int skipped = 0;
    int toRead = count < 512 ? (int) count : 512;
    IOSCharArray *charsSkipped = [[[IOSCharArray alloc] initWithLength:toRead] autorelease];
    while (skipped < count) {
      int read = [self readWithJavaLangCharacterArray:charsSkipped withInt:0 withInt:toRead];
      if (read == -1) {
        return skipped;
      }
      skipped += read;
      if (read < toRead) {
        return skipped;
      }
      if (count - skipped < toRead) {
        toRead = (int) (count - skipped);
      }
    }
    return skipped;
  }
}

- (int)readWithJavaNioCharBuffer:(JavaNioCharBuffer *)target {
  if (nil == target) {
    @throw [[[JavaLangNullPointerException alloc] init] autorelease];
  }
  int length = [((JavaNioCharBuffer *) NIL_CHK(target)) sequenceLength];
  IOSCharArray *buf = [[[IOSCharArray alloc] initWithLength:length] autorelease];
  length = [JavaLangMath minWithInt:length withInt:[self readWithJavaLangCharacterArray:buf]];
  if (length > 0) {
    [((JavaNioCharBuffer *) NIL_CHK(target)) putWithJavaLangCharacterArray:buf withInt:0 withInt:length];
  }
  return length;
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&lock_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaIoReader *typedCopy = (JavaIoReader *) copy;
  typedCopy.lock = lock_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:lock_ name:@"lock"]];
  return result;
}

@end
