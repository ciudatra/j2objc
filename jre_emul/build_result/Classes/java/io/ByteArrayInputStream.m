//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/io/ByteArrayInputStream.java
//
//  Created by retechretech on 13-4-19.
//

#import "IOSByteArray.h"
#import "java/io/ByteArrayInputStream.h"
#import "java/lang/IndexOutOfBoundsException.h"
#import "java/lang/NullPointerException.h"
#import "java/lang/System.h"

@implementation JavaIoByteArrayInputStream

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (IOSByteArray *)buf {
  return buf_;
}
- (void)setBuf:(IOSByteArray *)buf {
  JreOperatorRetainedAssign(&buf_, buf);
}
@synthesize buf = buf_;
@synthesize pos = pos_;
@synthesize mark_ = mark__;
@synthesize count = count_;

- (id)initWithJavaLangByteArray:(IOSByteArray *)buf {
  if ((self = [super init])) {
    self.mark_ = 0;
    self.buf = buf;
    self.count = (int) [((IOSByteArray *) NIL_CHK(buf)) count];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaLangByteArray:(IOSByteArray *)buf
                        withInt:(int)offset
                        withInt:(int)length {
  if ((self = [super init])) {
    self.buf = buf;
    pos_ = offset;
    mark__ = offset;
    count_ = offset + length > (int) [((IOSByteArray *) NIL_CHK(buf)) count] ? (int) [((IOSByteArray *) NIL_CHK(buf)) count] : offset + length;
    JreMemDebugAdd(self);
  }
  return self;
}

- (int)available {
  @synchronized(self) {
    {
      return count_ - pos_;
    }
  }
}

- (void)close {
}

- (void)markWithInt:(int)readlimit {
  @synchronized(self) {
    {
      mark__ = pos_;
    }
  }
}

- (BOOL)markSupported {
  return YES;
}

- (int)read {
  @synchronized(self) {
    {
      return pos_ < count_ ? [((IOSByteArray *) NIL_CHK(buf_)) byteAtIndex:pos_++] & (int) 0xFF : -1;
    }
  }
}

- (int)readWithJavaLangByteArray:(IOSByteArray *)b
                         withInt:(int)offset
                         withInt:(int)length {
  @synchronized(self) {
    {
      if (b == nil) {
        @throw [[[JavaLangNullPointerException alloc] init] autorelease];
      }
      if (offset < 0 || offset > (int) [((IOSByteArray *) NIL_CHK(b)) count] || length < 0 || length > (int) [((IOSByteArray *) NIL_CHK(b)) count] - offset) {
        @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
      }
      if (self.pos >= self.count) {
        return -1;
      }
      if (length == 0) {
        return 0;
      }
      int copylen = self.count - pos_ < length ? self.count - pos_ : length;
      [JavaLangSystem arraycopyWithId:buf_ withInt:pos_ withId:b withInt:offset withInt:copylen];
      pos_ += copylen;
      return copylen;
    }
  }
}

- (void)reset {
  @synchronized(self) {
    {
      pos_ = mark__;
    }
  }
}

- (long long int)skipWithLongInt:(long long int)n {
  @synchronized(self) {
    {
      if (n <= 0) {
        return 0;
      }
      int temp = pos_;
      pos_ = self.count - pos_ < n ? self.count : (int) (pos_ + n);
      return pos_ - temp;
    }
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JreOperatorRetainedAssign(&buf_, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  JavaIoByteArrayInputStream *typedCopy = (JavaIoByteArrayInputStream *) copy;
  typedCopy.buf = buf_;
  typedCopy.pos = pos_;
  typedCopy.mark_ = mark__;
  typedCopy.count = count_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:buf_ name:@"buf"]];
  return result;
}

@end
